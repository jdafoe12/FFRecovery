###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.5.9725/W32 for ARM        26/Oct/2022  20:51:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\sys\lpc313x\usb\mscuser.c
#    Command line =  
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\sys\lpc313x\usb\mscuser.c" -D BOOT_LEVEL_2 -lcN
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List" -o
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\prj\iar\..\..\"
#        -I "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\bsp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\csp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\lib\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\usb\" --cpu_mode thumb -Ol
#        --use_c++_inline
#    List file    =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List\mscuser.lst
#    Object file  =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj\mscuser.o
#
###############################################################################

C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\sys\lpc313x\usb\mscuser.c
      1          /*--------------------------------------------------------------------------
      2           * U S B  -  K e r n e l
      3           *--------------------------------------------------------------------------
      4           * Name:    mscuser.c
      5           * Purpose: Mass Storage Class Custom User Module
      6           * Version: V1.20
      7           *--------------------------------------------------------------------------
      8           * This software is supplied "AS IS" without any warranties, express,
      9           * implied or statutory, including but not limited to the implied
     10           * warranties of fitness for purpose, satisfactory quality and
     11           * noninfringement. Keil extends you a royalty-free right to reproduce
     12           * and distribute executable files created using this software for use
     13           * on NXP ARM microcontroller devices only. Nothing else gives
     14           * you the right to use this software.
     15           *
     16           * Copyright (c) 2008 Keil - An ARM Crane Chu. All rights reserved.
     17           * Adaption to LPCxxxx, Copyright (c) 2009 NXP.
     18           *--------------------------------------------------------------------------
     19           * History:
     20           *          V1.20 Added SCSI_READ12, SCSI_WRITE12
     21           *          V1.00 Initial Version
     22           *--------------------------------------------------------------------------*/
     23          
     24          #include "lpc_usb.h"
     25          #include "msc.h"
     26          #include "usbcfg.h"
     27          #include "usbhw.h"
     28          #include "usbcore.h"
     29          #include "mscuser.h"
     30          
     31          #include "drv_uart.h"
     32          
     33          #include <string.h>
     34          
     35          #include <onfm.h>
     36          
     37          #include <core\inc\buf.h>
     38          
     39          
     40          extern UNS_32 DevStatusFS2HS;
     41          
     42          UNS_32   MemOK;                        /* Memory OK */
     43          
     44          UNS_32   Offset;                       /* R/W SECTOR Offset */
     45          UNS_32   Length;                       /* R/W SECTOR Length */
     46          
     47          UNS_8*   BulkBuf;                      /* Bulk Out Buffer */
     48          
     49          UNS_32   BulkLen;                      /* Bulk In/Out Length */
     50          UNS_32   MSC_BlockCount;               /* block count in the volumn image */
     51          
     52          UNS_32   Read_BulkLen;
     53          
     54          #pragma data_alignment=DMA_BURST_BYTES
     55          UNS_8    Read_BulkBuf[MPP_SIZE];  /* Bulk In Buffer */
     56          #pragma data_alignment=DMA_BURST_BYTES
     57          UNS_8    CMD_BulkBuf[MSC_BlockSize];   /* Bulk In Buffer for commands */
     58          #pragma data_alignment=DMA_BURST_BYTES
     59          MSC_CBW  CBW;                          /* Command Block Wrapper */
     60          #pragma data_alignment=DMA_BURST_BYTES
     61          MSC_CSW  CSW;                          /* Command Status Wrapper */
     62          
     63          UNS_8    BulkStage;                    /* Bulk Stage */
     64          
     65          /* usb transaction list: move write operations to user space */
     66          USB_TRANSCATION  ut_list[UT_LIST_SIZE];
     67          volatile UNS_32  ut_pop;
     68          volatile UNS_32  ut_push;
     69          
     70          MERGE_STAGE    merge_stage;
     71          UNS_32         merge_count;
     72          
     73          static UNS_32 DataIn_Format(void);
     74          static void DataIn_Transfer(void);
     75          
     76          
     77          void MSC_Init()
     78          {
     79             /* allocate memory before 1st bulk */
     80             BulkBuf = NULL;
     81             Read_BulkLen = 0;
     82             merge_stage = MERGE_NONE;
     83             merge_count = 0;
     84          
     85             /* init the ut_list */
     86             ut_pop = 0;
     87             ut_push = 0;
     88             
     89             //jsjpenn
     90             //MSC_BlockCount = ONFM_Capacity();//原逻辑
     91             //多加了20个扇区，即5个LBA地址
     92             //由于预留的存MAPI的LEB块数有限，所以不能添加过多的LBA
     93             //原来g_LBAnum=240345，LBA为0~240344，现在LBA为0~240348
     94             MSC_BlockCount = ONFM_Capacity()+20;
     95          }
     96          
     97          
     98          void MSC_SetStallEP (UNS_32 EPNum)            /* set EP halt status according stall status */
     99          {
    100             USB_SetStallEP(EPNum);
    101             USB_EndPointHalt  |=  (EPNum & 0x80) ? ((1 << 16) << (EPNum & 0x0F)) : (1 << EPNum);
    102          }
    103          
    104          
    105          UNS_32 MSC_Reset(void)
    106          {
    107             USB_EndPointStall = 0x00000000;          /* EP must stay stalled */
    108             CSW.dSignature = 0;                      /* invalid signature */
    109          
    110             BulkStage = MSC_BS_CBW;
    111             return (TRUE);
    112          }
    113          
    114          
    115          UNS_32 MSC_GetMaxLUN(void)
    116          {
    117             EP0Buf[0] = 0;               /* No LUN associated with this device */
    118             return (TRUE);
    119          }
    120          
    121          
    122          void MSC_MemoryRead(void)
    123          {
    124             UNS_32   n;    /* sector count */
    125             int      onfm_ret = 0;
    126          
    127             if (DevStatusFS2HS)
    128             {
    129                /* read sectors aligned to a MPP */
    130                n = MIN(SECTOR_PER_MPP-(Offset%SECTOR_PER_MPP), Length);
    131          
    132                if ((Offset + n) > MSC_BlockCount)
    133                {
    134                   n = MSC_BlockCount - Offset;
    135                   BulkStage = MSC_BS_DATA_IN_LAST_STALL;
    136                }
    137             }
    138             else
    139             {
    140                onfm_ret = -1;
    141                n = 0;
    142             }
    143          
    144             if (onfm_ret == 0)
    145             {
    146                /* log the read operation to ut_list */
    147                ut_list[ut_push].type   = UT_READ;
    148                ut_list[ut_push].offset = Offset;
    149                ut_list[ut_push].length = n;
    150                ut_list[ut_push].buffer = Read_BulkBuf;
    151          
    152                /* handle ONFM read/write in user tasks */
    153                ut_push = (ut_push+1)%UT_LIST_SIZE;
    154                /* the ut_list should not be full */
    155                ASSERT(ut_push != ut_pop);
    156          
    157                Read_BulkLen = 0;
    158          
    159                Offset += n;
    160                Length -= n;
    161          
    162                CSW.dDataResidue -= (n*MSC_BlockSize);
    163             }
    164          }
    165          
    166          void MSC_MemoryWrite(void)
    167          {
    168             UNS_32   n;    /* sector count */
    169          
    170             /* BulkLen should be align to sector size */
    171             if (BulkLen%MSC_BlockSize == 0)
    172             {
    173                n = BulkLen/MSC_BlockSize;
    174          
    175                if ((Offset + n) > MSC_BlockCount)
    176                {
    177                   BulkLen = (MSC_BlockCount - Offset)*MSC_BlockSize;
    178                   BulkStage = MSC_BS_CSW;
    179                   MSC_SetStallEP(MSC_EP_OUT);
    180                }
    181          
    182                /* log the write operation to ut_list */
    183                ut_list[ut_push].type   = UT_WRITE;
    184                ut_list[ut_push].offset = Offset&(~(SECTOR_PER_MPP-1));
    185                ut_list[ut_push].length = SECTOR_PER_MPP;//4
    186                ut_list[ut_push].buffer = BulkBuf;
    187          
    188                /* handle ONFM read/write in user tasks */
    189                ut_push = (ut_push+1)%UT_LIST_SIZE;
    190                /* the ut_list should not be full */
    191                ASSERT(ut_push != ut_pop);
    192          
    193                Offset += n;
    194                Length -= n;
    195                CSW.dDataResidue -= BulkLen;
    196          
    197                if ((Length == 0) || (BulkStage == MSC_BS_CSW))
    198                {
    199                   CSW.bStatus = CSW_CMD_PASSED;
    200                   MSC_SetCSW();
    201                }
    202             }
    203          }
    204          
    205          
    206          void MSC_MemoryVerify(void)
    207          {
    208             Offset += Length;
    209             Length = 0;
    210          
    211             CSW.dDataResidue = 0;
    212             CSW.bStatus = CSW_CMD_PASSED;
    213          
    214             MSC_SetCSW();
    215          }
    216          
    217          
    218          UNS_32 MSC_RWSetup(void)
    219          {
    220             UNS_32 n;
    221          
    222             /* Logical Block Address of First Block */
    223             n = (CBW.CB[2] << 24) |
    224                 (CBW.CB[3] << 16) |
    225                 (CBW.CB[4] <<  8) |
    226                 (CBW.CB[5] <<  0);
    227          
    228             Offset = n;
    229          
    230             /* Number of Blocks to transfer */
    231             switch (CBW.CB[0])
    232             {
    233                case SCSI_READ10:
    234                case SCSI_WRITE10:
    235                case SCSI_VERIFY10:
    236                   n = (CBW.CB[7] <<  8) |
    237                       (CBW.CB[8] <<  0);
    238                   break;
    239          
    240                case SCSI_READ12:
    241                case SCSI_WRITE12:
    242                   n = (CBW.CB[6] << 24) |
    243                       (CBW.CB[7] << 16) |
    244                       (CBW.CB[8] <<  8) |
    245                       (CBW.CB[9] <<  0);
    246                   break;
    247             }
    248          
    249             Length = n;
    250          
    251             if (CBW.dDataLength == 0)                /* host requests no data */
    252             {
    253                CSW.bStatus = CSW_CMD_FAILED;
    254                MSC_SetCSW();
    255                return (FALSE);
    256             }
    257          
    258             if (CBW.dDataLength != (n*MSC_BlockSize))
    259             {
    260                if ((CBW.bmFlags & 0x80) != 0)         /* stall appropriate EP */
    261                {
    262                   MSC_SetStallEP(MSC_EP_IN);
    263                }
    264                else
    265                {
    266                   MSC_SetStallEP(MSC_EP_OUT);
    267                }
    268          
    269                CSW.bStatus = CSW_CMD_FAILED;
    270                MSC_SetCSW();
    271          
    272                return (FALSE);
    273             }
    274          
    275             return (TRUE);
    276          }
    277          
    278          
    279          void MSC_TestUnitReady(void)
    280          {
    281          
    282             if (CBW.dDataLength != 0)
    283             {
    284                if ((CBW.bmFlags & 0x80) != 0)
    285                {
    286                   MSC_SetStallEP(MSC_EP_IN);
    287                }
    288                else
    289                {
    290                   MSC_SetStallEP(MSC_EP_OUT);
    291                }
    292             }
    293          
    294             CSW.bStatus = CSW_CMD_PASSED;
    295             MSC_SetCSW();
    296          }
    297          
    298          
    299          void MSC_RequestSense (void)
    300          {
    301             if (!DataIn_Format()) return;
    302          
    303             CMD_BulkBuf[ 0] = 0x70;          /* Response Code */
    304             CMD_BulkBuf[ 1] = 0x00;
    305             CMD_BulkBuf[ 2] = 0x02;          /* Sense Key */
    306             CMD_BulkBuf[ 3] = 0x00;
    307             CMD_BulkBuf[ 4] = 0x00;
    308             CMD_BulkBuf[ 5] = 0x00;
    309             CMD_BulkBuf[ 6] = 0x00;
    310             CMD_BulkBuf[ 7] = 0x0A;          /* Additional Length */
    311             CMD_BulkBuf[ 8] = 0x00;
    312             CMD_BulkBuf[ 9] = 0x00;
    313             CMD_BulkBuf[10] = 0x00;
    314             CMD_BulkBuf[11] = 0x00;
    315             CMD_BulkBuf[12] = 0x30;          /* ASC */
    316             CMD_BulkBuf[13] = 0x01;          /* ASCQ */
    317             CMD_BulkBuf[14] = 0x00;
    318             CMD_BulkBuf[15] = 0x00;
    319             CMD_BulkBuf[16] = 0x00;
    320             CMD_BulkBuf[17] = 0x00;
    321          
    322             BulkLen = 18;
    323             DataIn_Transfer();
    324          }
    325          
    326          
    327          void MSC_Inquiry(void)
    328          {
    329             if (!DataIn_Format()) return;
    330          
    331             CMD_BulkBuf[ 0] = 0x00;          /* Direct Access Device */
    332             CMD_BulkBuf[ 1] = 0x80;          /* RMB = 1: Removable Medium */
    333             CMD_BulkBuf[ 2] = 0x00;          /* Version: No conformance claim to standard */
    334             CMD_BulkBuf[ 3] = 0x01;
    335          
    336             CMD_BulkBuf[ 4] = 36 - 4;        /* Additional Length */
    337             CMD_BulkBuf[ 5] = 0x80;          /* SCCS = 1: Storage Controller Component */
    338             CMD_BulkBuf[ 6] = 0x00;
    339             CMD_BulkBuf[ 7] = 0x00;
    340          
    341             CMD_BulkBuf[ 8] = 'C';           /* Vendor Identification */
    342             CMD_BulkBuf[ 9] = 'r';
    343             CMD_BulkBuf[10] = 'a';
    344             CMD_BulkBuf[11] = 'n';
    345             CMD_BulkBuf[12] = 'e';
    346             CMD_BulkBuf[13] = '5';
    347             CMD_BulkBuf[14] = '4';
    348             CMD_BulkBuf[15] = '4';
    349          
    350             CMD_BulkBuf[16] = 'O';           /* Product Identification */
    351             CMD_BulkBuf[17] = 'p';
    352             CMD_BulkBuf[18] = 'e';
    353             CMD_BulkBuf[19] = 'n';
    354             CMD_BulkBuf[20] = ' ';
    355             CMD_BulkBuf[21] = 'N';
    356             CMD_BulkBuf[22] = 'A';
    357             CMD_BulkBuf[23] = 'N';
    358             CMD_BulkBuf[24] = 'D';
    359             CMD_BulkBuf[25] = 'F';
    360             CMD_BulkBuf[26] = ' ';
    361             CMD_BulkBuf[27] = 'M';
    362             CMD_BulkBuf[28] = 'g';
    363             CMD_BulkBuf[29] = 'r';
    364             CMD_BulkBuf[30] = ' ';
    365             CMD_BulkBuf[31] = ' ';
    366          
    367             CMD_BulkBuf[32] = '0';           /* Product Revision Level */
    368             CMD_BulkBuf[33] = '.';
    369             CMD_BulkBuf[34] = '1';
    370             CMD_BulkBuf[35] = ' ';
    371          
    372             BulkLen = 36;
    373             DataIn_Transfer();
    374          }
    375          
    376          
    377          void MSC_ModeSense6(void)
    378          {
    379             if (!DataIn_Format()) return;
    380          
    381             CMD_BulkBuf[ 0] = 0x03;
    382             CMD_BulkBuf[ 1] = 0x00;
    383             CMD_BulkBuf[ 2] = 0x00;
    384             CMD_BulkBuf[ 3] = 0x00;
    385          
    386             BulkLen = 4;
    387             DataIn_Transfer();
    388          }
    389          
    390          
    391          void MSC_ModeSense10(void)
    392          {
    393             if (!DataIn_Format()) return;
    394          
    395             CMD_BulkBuf[ 0] = 0x00;
    396             CMD_BulkBuf[ 1] = 0x06;
    397             CMD_BulkBuf[ 2] = 0x00;
    398             CMD_BulkBuf[ 3] = 0x00;
    399             CMD_BulkBuf[ 4] = 0x00;
    400             CMD_BulkBuf[ 5] = 0x00;
    401             CMD_BulkBuf[ 6] = 0x00;
    402             CMD_BulkBuf[ 7] = 0x00;
    403          
    404             BulkLen = 8;
    405             DataIn_Transfer();
    406          }
    407          
    408          
    409          void MSC_ReadCapacity(void)
    410          {
    411          
    412             if (!DataIn_Format()) return;
    413          
    414             /* Last Logical Block */
    415             CMD_BulkBuf[ 0] = ((MSC_BlockCount - 1) >> 24) & 0xFF;
    416             CMD_BulkBuf[ 1] = ((MSC_BlockCount - 1) >> 16) & 0xFF;
    417             CMD_BulkBuf[ 2] = ((MSC_BlockCount - 1) >>  8) & 0xFF;
    418             CMD_BulkBuf[ 3] = ((MSC_BlockCount - 1) >>  0) & 0xFF;
    419          
    420             /* Block Length */
    421             CMD_BulkBuf[ 4] = (MSC_BlockSize >> 24) & 0xFF;
    422             CMD_BulkBuf[ 5] = (MSC_BlockSize >> 16) & 0xFF;
    423             CMD_BulkBuf[ 6] = (MSC_BlockSize >>  8) & 0xFF;
    424             CMD_BulkBuf[ 7] = (MSC_BlockSize >>  0) & 0xFF;
    425          
    426             BulkLen = 8;
    427             DataIn_Transfer();
    428          }
    429          
    430          
    431          void MSC_ReadFormatCapacity(void)
    432          {
    433             if (!DataIn_Format()) return;
    434          
    435             CMD_BulkBuf[ 0] = 0x00;
    436             CMD_BulkBuf[ 1] = 0x00;
    437             CMD_BulkBuf[ 2] = 0x00;
    438             CMD_BulkBuf[ 3] = 0x08;          /* Capacity List Length */
    439          
    440             /* Block Count */
    441             CMD_BulkBuf[ 4] = (MSC_BlockCount >> 24) & 0xFF;
    442             CMD_BulkBuf[ 5] = (MSC_BlockCount >> 16) & 0xFF;
    443             CMD_BulkBuf[ 6] = (MSC_BlockCount >>  8) & 0xFF;
    444             CMD_BulkBuf[ 7] = (MSC_BlockCount >>  0) & 0xFF;
    445          
    446             /* Block Length */
    447             CMD_BulkBuf[ 8] = 0x02;          /* Descriptor Code: Formatted Media */
    448             CMD_BulkBuf[ 9] = (MSC_BlockSize >> 16) & 0xFF;
    449             CMD_BulkBuf[10] = (MSC_BlockSize >>  8) & 0xFF;
    450             CMD_BulkBuf[11] = (MSC_BlockSize >>  0) & 0xFF;
    451          
    452             BulkLen = 12;
    453             DataIn_Transfer();
    454          }
    455          
    456          
    457          void MSC_GetCBW(void)
    458          {
    459             if ((BulkLen == sizeof(CBW)) && (CBW.dSignature == MSC_CBW_Signature))
    460             {
    461                /* Valid CBW */
    462                CSW.dTag = CBW.dTag;
    463                CSW.dDataResidue = CBW.dDataLength;
    464                if ((CBW.bLUN != 0)     ||
    465                    (CBW.bCBLength < 1) ||
    466                    (CBW.bCBLength > 16) )
    467                {
    468          fail:
    469                   CSW.bStatus = CSW_CMD_FAILED;
    470                   MSC_SetCSW();
    471                }
    472                else
    473                {
    474                   switch (CBW.CB[0])
    475                   {
    476                      case SCSI_TEST_UNIT_READY:
    477                         MSC_TestUnitReady();
    478                         break;
    479                      case SCSI_REQUEST_SENSE:
    480                         MSC_RequestSense();
    481                         break;
    482                      case SCSI_FORMAT_UNIT:
    483                         goto fail;
    484                      case SCSI_INQUIRY:
    485                         MSC_Inquiry();
    486                         break;
    487                      case SCSI_START_STOP_UNIT:
    488                         goto fail;
    489                      case SCSI_MEDIA_REMOVAL:
    490                         goto fail;
    491                      case SCSI_MODE_SELECT6:
    492                         goto fail;
    493                      case SCSI_MODE_SENSE6:
    494                         MSC_ModeSense6();
    495                         break;
    496                      case SCSI_MODE_SELECT10:
    497                         goto fail;
    498                      case SCSI_MODE_SENSE10:
    499                         MSC_ModeSense10();
    500                         break;
    501                      case SCSI_READ_FORMAT_CAPACITIES:
    502                         MSC_ReadFormatCapacity();
    503                         break;
    504                      case SCSI_READ_CAPACITY:
    505                         MSC_ReadCapacity();
    506                         break;
    507                      case SCSI_READ10:
    508                      case SCSI_READ12:
    509                         if (MSC_RWSetup())
    510                         {
    511                            if ((CBW.bmFlags & 0x80) != 0)
    512                            {
    513                               BulkStage = MSC_BS_DATA_IN;
    514                               MSC_MemoryRead();
    515                            }
    516                            else
    517                            {
    518                               MSC_SetStallEP(MSC_EP_OUT);
    519                               CSW.bStatus = CSW_PHASE_ERROR;
    520                               MSC_SetCSW();
    521                            }
    522                         }
    523                         break;
    524                      case SCSI_WRITE10:
    525                      case SCSI_WRITE12:
    526                         if (MSC_RWSetup())
    527                         {
    528                            if ((CBW.bmFlags & 0x80) == 0)
    529                            {
    530                               BulkStage = MSC_BS_DATA_OUT;
    531                            }
    532                            else
    533                            {
    534                               MSC_SetStallEP(MSC_EP_IN);
    535                               CSW.bStatus = CSW_PHASE_ERROR;
    536                               MSC_SetCSW();
    537                            }
    538                         }
    539                         break;
    540                      case SCSI_VERIFY10:
    541                         if ((CBW.CB[1] & 0x02) == 0)
    542                         {
    543                            // BYTCHK = 0 -> CRC Check (not implemented)
    544                            CSW.bStatus = CSW_CMD_PASSED;
    545                            MSC_SetCSW();
    546                            break;
    547                         }
    548          
    549                         if (MSC_RWSetup())
    550                         {
    551                            if ((CBW.bmFlags & 0x80) == 0)
    552                            {
    553                               BulkStage = MSC_BS_DATA_OUT;
    554                               MemOK = TRUE;
    555                            }
    556                            else
    557                            {
    558                               MSC_SetStallEP(MSC_EP_IN);
    559                               CSW.bStatus = CSW_PHASE_ERROR;
    560                               MSC_SetCSW();
    561                            }
    562                         }
    563                         break;
    564                      default:
    565                         goto fail;
    566                   }
    567                }
    568             }
    569             else
    570             {
    571                /* Invalid CBW */
    572                MSC_SetStallEP(MSC_EP_IN);
    573                /* set EP to stay stalled */
    574                USB_EndPointStall |=  (1 << (16 + (MSC_EP_IN  & 0x0F)));
    575                MSC_SetStallEP(MSC_EP_OUT);
    576                /* set EP to stay stalled */
    577                USB_EndPointStall |=  (1 << MSC_EP_OUT);
    578                BulkStage = MSC_BS_ERROR;
    579             }
    580          }
    581          
    582          
    583          void MSC_SetCSW(void)
    584          {
    585             CSW.dSignature = MSC_CSW_Signature;
    586             USB_WriteEP(MSC_EP_IN, (UNS_8 *)&CSW, sizeof(CSW));
    587             BulkStage = MSC_BS_CSW;
    588          }
    589          
    590          
    591          void MSC_BulkInNak(void)
    592          {
    593             if (Read_BulkLen != 0)
    594             {
    595                /* read buffer is ready to prime */
    596                USB_WriteEP(MSC_EP_IN, Read_BulkBuf, Read_BulkLen);
    597          
    598                if (Length == 0)
    599                {
    600                   BulkStage = MSC_BS_DATA_IN_LAST;
    601                }
    602          
    603                if (BulkStage != MSC_BS_DATA_IN)
    604                {
    605                   CSW.bStatus = CSW_CMD_PASSED;
    606                }
    607          
    608                /* TODO: pre-read the next page.
    609                 * - log pre-read to the task list
    610                 * - ONFM read the page out, when USB is sending the current page
    611                 * - ONFM check the pre-read buffer before read it from NAND
    612                 * - ONFM return the address of buffer, avoid another copying. 
    613                 */
    614             }
    615          }
    616          
    617          
    618          void MSC_BulkIn(void)
    619          {
    620             switch (BulkStage)
    621             {
    622                case MSC_BS_DATA_IN:
    623                   switch (CBW.CB[0])
    624                   {
    625                      case SCSI_READ10:
    626                      case SCSI_READ12:
    627                         MSC_MemoryRead();
    628                         break;
    629                   }
    630                   break;
    631                case MSC_BS_DATA_IN_LAST:
    632                   MSC_SetCSW();
    633                   break;
    634                case MSC_BS_DATA_IN_LAST_STALL:
    635                   MSC_SetStallEP(MSC_EP_IN);
    636                   MSC_SetCSW();
    637                   break;
    638                case MSC_BS_CSW:
    639                   BulkStage = MSC_BS_CBW;
    640                   break;
    641             }
    642          }
    643          
    644          
    645          void MSC_BulkOutNak(void)
    646          {
    647             UNS_32   n;
    648             UNS_32   bulkout_len;
    649             void*    buffer = NULL;
    650          
    651             if (DevStatusFS2HS)
    652             {
    653                if (BulkStage == MSC_BS_DATA_OUT)
    654                {
    655                   if (merge_stage == MERGE_START)
    656                   {
    657                      /* not prime before get merged data */
    658                      buffer = NULL;
    659                      bulkout_len = 0;
    660                   }
    661                   else if (merge_stage == MERGE_FINISH)
    662                   {
    663                      buffer = BulkBuf+(Offset%SECTOR_PER_MPP)*MSC_BlockSize;
    664                      bulkout_len = merge_count*MSC_BlockSize;
    665          
    666                      merge_stage = MERGE_NONE;
    667                      merge_count = 0;
    668                   }
    669                   else
    670                   {
    671                      ASSERT(merge_stage == MERGE_NONE);
    672          
    673                      /* try to allocate buffer for next bulk */
    674                      BulkBuf = BUF_Allocate();
    675                      if (BulkBuf != NULL)
    676                      {
    677                         /* sector counts to write in MPP aligned */
    678                         n = MIN(SECTOR_PER_MPP-(Offset%SECTOR_PER_MPP), Length);
    679          
    680                         /* merge non-aligned or non-full bulk */
    681                         if (n != SECTOR_PER_MPP)
    682                         {
    683                            /* log the read-for-merge operation to ut_list */
    684                            ut_list[ut_push].type   = UT_MERGE;
    685                            ut_list[ut_push].offset = Offset&(~(SECTOR_PER_MPP-1));
    686                            ut_list[ut_push].length = SECTOR_PER_MPP;
    687                            ut_list[ut_push].buffer = BulkBuf;
    688          
    689                            /* handle ONFM read/write in user tasks */
    690                            ut_push = (ut_push+1)%UT_LIST_SIZE;
    691                            /* the ut_list should not be full */
    692                            ASSERT(ut_push != ut_pop);
    693          
    694                            merge_stage = MERGE_START;
    695                            merge_count = n;
    696          
    697                            /* not prime before get merged data */
    698                            buffer = NULL;
    699                            bulkout_len = 0;
    700                         }
    701                         else
    702                         {
    703                            /* CASE 1: data buffer aligned to MPP */
    704                            buffer = BulkBuf;
    705                            bulkout_len = MPP_SIZE;
    706                         }
    707                      }
    708                      else
    709                      {
    710                         /* CASE 2: no buffer avaliable */
    711                         buffer = NULL;
    712                         bulkout_len = 0;
    713                      }
    714                   }
    715                }
    716                else if (BulkStage == MSC_BS_CBW)
    717                {
    718                   /* CASE 3: write data to CBW directly */
    719                   buffer = &CBW;
    720                   bulkout_len = sizeof(CBW);
    721                }
    722             }
    723          
    724             if (buffer != NULL)
    725             {
    726                USB_ReadReqEP(MSC_EP_OUT, buffer, bulkout_len);
    727             }
    728             else
    729             {
    730                /* if no buffer avaliable in device, skip priming OUT endpoint, and
    731                 * then, a NAK will be sent to host in next transmittion. At that time,
    732                 * we will try to allocate buffer again here. The buffer may be released
    733                 * due to program completed.
    734                 */
    735                ;
    736             }
    737          }
    738          
    739          
    740          void MSC_BulkOut(void)
    741          {
    742             BulkLen = USB_ReadEP(MSC_EP_OUT, BulkBuf);
    743             switch (BulkStage)
    744             {
    745                case MSC_BS_CBW:
    746                   MSC_GetCBW();
    747                   break;
    748                case MSC_BS_DATA_OUT:
    749                   switch (CBW.CB[0])
    750                   {
    751                      case SCSI_WRITE10:
    752                      case SCSI_WRITE12:
    753                         MSC_MemoryWrite();
    754                         break;
    755                      case SCSI_VERIFY10:
    756                         MSC_MemoryVerify();
    757                         break;
    758                   }
    759                   break;
    760                case MSC_BS_CSW:
    761                   break;
    762                default:
    763                   MSC_SetStallEP(MSC_EP_OUT);
    764                   CSW.bStatus = CSW_PHASE_ERROR;
    765                   MSC_SetCSW();
    766                   break;
    767             }
    768          }
    769          
    770          
    771          static
    772          UNS_32 DataIn_Format(void)
    773          {
    774             if (CBW.dDataLength == 0)
    775             {
    776                CSW.bStatus = CSW_PHASE_ERROR;
    777                MSC_SetCSW();
    778                return (FALSE);
    779             }
    780          
    781             if ((CBW.bmFlags & 0x80) == 0)
    782             {
    783                MSC_SetStallEP(MSC_EP_OUT);
    784                CSW.bStatus = CSW_PHASE_ERROR;
    785                MSC_SetCSW();
    786                return (FALSE);
    787             }
    788          
    789             return (TRUE);
    790          }
    791          
    792          
    793          static
    794          void DataIn_Transfer(void)
    795          {
    796             BulkLen = MIN(BulkLen, CBW.dDataLength);
    797             BulkStage = MSC_BS_DATA_IN_LAST;
    798          
    799             USB_WriteEP(MSC_EP_IN, CMD_BulkBuf, BulkLen);
    800          
    801             CSW.dDataResidue = 0;
    802             CSW.bStatus = CSW_CMD_PASSED;
    803          }
    804          
    805          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DataIn_Format
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
       8   DataIn_Transfer
         8   -> USB_WriteEP
       8   MSC_BulkIn
         8   -> MSC_MemoryRead
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
       8   MSC_BulkInNak
         8   -> USB_WriteEP
       8   MSC_BulkOut
         8   -> MSC_GetCBW
         8   -> MSC_MemoryVerify
         8   -> MSC_MemoryWrite
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
         8   -> USB_ReadEP
       8   MSC_BulkOutNak
         8   -> BUF_Allocate
         8   -> USB_ReadReqEP
         8 __aeabi_uidivmod
       8   MSC_GetCBW
         8   -> MSC_Inquiry
         8   -> MSC_MemoryRead
         8   -> MSC_ModeSense10
         8   -> MSC_ModeSense6
         8   -> MSC_RWSetup
         8   -> MSC_ReadCapacity
         8   -> MSC_ReadFormatCapacity
         8   -> MSC_RequestSense
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
         8   -> MSC_TestUnitReady
       0   MSC_GetMaxLUN
       8   MSC_Init
         8   -> ONFM_Capacity
       8   MSC_Inquiry
         8   -> DataIn_Format
         8   -> DataIn_Transfer
      12   MSC_MemoryRead
        12 __aeabi_uidivmod
       8   MSC_MemoryVerify
         8   -> MSC_SetCSW
       8   MSC_MemoryWrite
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
         8 __aeabi_uidivmod
       8   MSC_ModeSense10
         8   -> DataIn_Format
         8   -> DataIn_Transfer
       8   MSC_ModeSense6
         8   -> DataIn_Format
         8   -> DataIn_Transfer
       8   MSC_RWSetup
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP
       8   MSC_ReadCapacity
         8   -> DataIn_Format
         8   -> DataIn_Transfer
       8   MSC_ReadFormatCapacity
         8   -> DataIn_Format
         8   -> DataIn_Transfer
       8   MSC_RequestSense
         8   -> DataIn_Format
         8   -> DataIn_Transfer
       0   MSC_Reset
       8   MSC_SetCSW
         8   -> USB_WriteEP
       8   MSC_SetStallEP
         8   -> USB_SetStallEP
       8   MSC_TestUnitReady
         8   -> MSC_SetCSW
         8   -> MSC_SetStallEP


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  BulkBuf
       4  BulkLen
       1  BulkStage
      32  CBW
     512  CMD_BulkBuf
      16  CSW
      56  DataIn_Format
      64  DataIn_Transfer
       4  Length
       4  MSC_BlockCount
      68  MSC_BulkIn
      52  MSC_BulkInNak
      88  MSC_BulkOut
     316  MSC_BulkOutNak
     406  MSC_GetCBW
      10  MSC_GetMaxLUN
      50  MSC_Init
     238  MSC_Inquiry
     230  MSC_MemoryRead
      40  MSC_MemoryVerify
     230  MSC_MemoryWrite
      70  MSC_ModeSense10
      46  MSC_ModeSense6
     182  MSC_RWSetup
      92  MSC_ReadCapacity
     108  MSC_ReadFormatCapacity
     130  MSC_RequestSense
      22  MSC_Reset
      26  MSC_SetCSW
      42  MSC_SetStallEP
      44  MSC_TestUnitReady
       4  MemOK
       4  Offset
    2048  Read_BulkBuf
       4  Read_BulkLen
       4  merge_count
       1  merge_stage
     128  ut_list
       4  ut_pop
       4  ut_push

 
 2 778 bytes in section .bss
 2 822 bytes in section .text
 
 2 822 bytes of CODE memory
 2 778 bytes of DATA memory

Errors: none
Warnings: 3
