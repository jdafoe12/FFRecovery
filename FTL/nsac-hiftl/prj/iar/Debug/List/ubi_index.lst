###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.5.9725/W32 for ARM        26/Oct/2022  20:51:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\core\ubi\ubi_index.c
#    Command line =  
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\core\ubi\ubi_index.c" -D BOOT_LEVEL_2 -lcN
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List" -o
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\prj\iar\..\..\"
#        -I "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\bsp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\csp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\lib\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\usb\" --cpu_mode thumb -Ol
#        --use_c++_inline
#    List file    =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List\ubi_index.lst
#    Object file  =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj\ubi_index.o
#
###############################################################################

C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\core\ubi\ubi_index.c
      1          /*********************************************************
      2           * Module name: ubi_index.c
      3           *
      4           * Copyright 2010, 2011. All Rights Reserved, Crane Chu.
      5           *
      6           * This file is part of OpenNFM.
      7           *
      8           * OpenNFM is free software: you can redistribute it and/or 
      9           * modify it under the terms of the GNU General Public 
     10           * License as published by the Free Software Foundation, 
     11           * either version 3 of the License, or (at your option) any 
     12           * later version.
     13           * 
     14           * OpenNFM is distributed in the hope that it will be useful,
     15           * but WITHOUT ANY WARRANTY; without even the implied 
     16           * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     17           * PURPOSE. See the GNU General Public License for more 
     18           * details.
     19           *
     20           * You should have received a copy of the GNU General Public 
     21           * License along with OpenNFM. If not, see 
     22           * <http://www.gnu.org/licenses/>.
     23           *
     24           * First written on 2010-01-01 by cranechu@gmail.com
     25           *
     26           * Module Description:
     27           *    Manage index table in ram and nand.
     28           *
     29           *********************************************************/
     30          
     31          #include <core\inc\cmn.h>
     32          #include <core\inc\mtd.h>
     33          #include <sys\sys.h>
     34          #include "ubi_inc.h"
     35          
     36          /*
     37           * ANCHOR table is not managed by FTL/TABLE module. It is self-PLR-safe.
     38           *
     39           * To achieve the Static Wear Leveling (SWL), the EC of every PHY_BLOCK
     40           * is traced in Erase Count Table (ECT), which is located in the following
     41           * sector of above tables. SWL works as a background task. A block in a area,
     42           * which has the minimal EC, is selected, and switched with the first
     43           * block in FBT, only when the difference of their ECs is larger than a
     44           * predefined threhold. In this way, the static blocks can be found and used.
     45           *
     46           * An index table has 4 sectors. The 1st sector is ZIT, the 2nd is ECT
     47           * of ZIT; the 3rd one has FBT, IBT, CBT, RBT, RFT, and the 4th one is the ECT.
     48           */
     49          
     50             
     51          //jsjpenn  
     52          
     53          STATUS index_update();//为了能在ubi_area.c中调用index_update()
     54          
     55          
     56          
     57          INDEX_TABLE index_table;
     58          
     59          /* current index table block, and its erase count */
     60          static PHY_BLOCK index_block;
     61          static ERASE_COUNT index_block_ec;
     62          static PAGE_OFF index_next_page;
     63          static BOOL is_updating_area = FALSE;
     64          
     65          PHY_BLOCK INDEX_Format(PHY_BLOCK total_block, PHY_BLOCK fmt_current_block) {
     66            UINT32 i;
     67            UINT32 free_block_index = 0;
     68            PHY_BLOCK index_block = INVALID_BLOCK;
     69            STATUS ret = STATUS_SUCCESS;
     70          
     71            /* clear plr info */
     72            index_table.area_update_plr.area_updating_logical_block = INVALID_BLOCK;
     73            index_table.area_update_plr.area_updating_physical_block = INVALID_BLOCK;
     74            index_table.area_update_plr.area_updating_block_ec = INVALID_EC;
     75          
     76            /* free block table: all remaining block */
     77            for (i = 0; fmt_current_block < total_block; fmt_current_block++, i++) {
     78              /* log good block, discard bad block */
     79              if (ANCHOR_IsBadBlock(fmt_current_block) == FALSE) {
     80                ret = MTD_Erase(fmt_current_block);
     81                if (ret != STATUS_SUCCESS) {
     82                  /* mark bad block */
     83                  ANCHOR_LogBadBlock(fmt_current_block);
     84                }
     85              } 
     86              else {
     87                ret = STATUS_BADBLOCK;
     88              }
     89              if (ret == STATUS_SUCCESS) {
     90                if (index_block == INVALID_BLOCK) {
     91                  /* the first free block should be reserved for index block */
     92                  index_block = fmt_current_block;
     93                  
     94                } else {
     95                  /* the reserved free block in block index table should be large
     96                   * enough to hold the 2% reserved free block of total block count.
     97                   */
     98                  ASSERT(free_block_index < FREE_BLOCK_COUNT);
     99                  index_table.free_block_table[free_block_index] = fmt_current_block;
    100                  index_table.free_block_ect[free_block_index] = 0;
    101                  free_block_index++;
    102                }
    103              }
    104            }  
    105           
    106          
    107            /* fill all remaining free block table as invalid block */
    108            for (i = free_block_index; i < FREE_BLOCK_COUNT; i++) {
    109              index_table.free_block_table[i] = INVALID_BLOCK;
    110              index_table.free_block_ect[i] = INVALID_EC;
    111            }
    112            ASSERT(sizeof(index_table) == MPP_SIZE);
    113          
    114            /* write index table, with EC sectors */
    115            if (index_block == INVALID_BLOCK) {
    116              ASSERT(ret != STATUS_SUCCESS);
    117            }
    118          
    119            /* write area table, with EC sector, check and erase block first */
    120            if (ret == STATUS_SUCCESS) {
    121              if (ANCHOR_IsBadBlock(index_block) == TRUE) {
    122                ret = STATUS_BADBLOCK;
    123              }
    124            }
    125          
    126            if (ret == STATUS_SUCCESS) {
    127              ret = MTD_Erase(index_block);
    128            }
    129          
    130            if (ret == STATUS_SUCCESS) {       
    131              ret = TABLE_Write(index_block, 0, &index_table);    
    132            }
    133          
    134            if (ret == STATUS_SUCCESS) {
    135              /* setup index block info in cfg table */
    136              anchor_table.index_new_block = index_block;
    137              anchor_table.index_new_ec = 0;
    138              anchor_table.index_old_block = INVALID_BLOCK;
    139              anchor_table.index_old_ec = INVALID_EC;
    140            } else {
    141              /* mark bad block, pick another block for index. */
    142              ANCHOR_LogBadBlock(index_block);
    143              fmt_current_block = INVALID_BLOCK;
    144            }
    145            return fmt_current_block;
    146          }
    147          
    148          
    149          //jsjpenn
    150          extern PAGE_OFF area_offset_table[AREA_TABLE_SIZE];//128
    151          
    152          
    153          STATUS INDEX_Init(PHY_BLOCK* logical_block, PHY_BLOCK* origin_block,
    154                            ERASE_COUNT* block_ec) {
    155            PAGE_OFF page_offset = INVALID_OFFSET;
    156            STATUS ret = STATUS_FAILURE;
    157          
    158            is_updating_area = FALSE;
    159          
    160            /* PLR of index block reclaim: try to read new block first */
    161            ASSERT(anchor_table.index_new_block != INVALID_BLOCK);
    162            ret = TABLE_Read(anchor_table.index_new_block, &page_offset, &index_table);
    163            if (ret == STATUS_SUCCESS) {
    164              /* the new block has valid index table */
    165              index_block = anchor_table.index_new_block;
    166              index_block_ec = anchor_table.index_new_ec;
    167              index_next_page = page_offset + 1;
    168              /* this page may be written before PL, just write it to overwrite it */
    169              (void) index_update();
    170            } else {
    171              /* can not get correct data from new block, read in old block for PLR */
    172              ASSERT(anchor_table.index_old_block != INVALID_BLOCK);
    173              ret = TABLE_Read(anchor_table.index_old_block, &page_offset, &index_table);
    174              if (ret == STATUS_SUCCESS) {
    175                /* finish the reclaim before PL */
    176                index_block = anchor_table.index_old_block;
    177                index_block_ec = anchor_table.index_old_ec;
    178                index_next_page = PAGE_PER_PHY_BLOCK;
    179                /* update index table to new block */
    180                ret = index_update();
    181              }
    182            }
    183          
    184            /* set up the area plr info */
    185            *logical_block = index_table.area_update_plr.area_updating_logical_block;
    186            *origin_block = index_table.area_update_plr.area_updating_physical_block;
    187            *block_ec = index_table.area_update_plr.area_updating_block_ec;
    188            
    189            return ret;
    190          }
    191          
    192          void INDEX_Update_AreaReclaim(AREA area, PHY_BLOCK new_block, ERASE_COUNT nec) {
    193            /* release old area block */
    194            INDEX_FreeBlock_Put(index_table.area_index_table[area],
    195                                index_table.area_index_ect[area]);
    196          
    197            /* setup new area block */
    198            index_table.area_index_table[area] = new_block;
    199            index_table.area_index_ect[area] = nec;
    200          }
    201          
    202          void INDEX_Update_AreaUpdate(LOG_BLOCK logical_block, PHY_BLOCK physical_block,
    203                                       ERASE_COUNT block_ec) {
    204            ASSERT(physical_block != INVALID_BLOCK && block_ec != INVALID_EC);
    205          
    206            index_table.area_update_plr.area_updating_logical_block = logical_block;
    207            index_table.area_update_plr.area_updating_physical_block = physical_block;
    208            index_table.area_update_plr.area_updating_block_ec = block_ec;
    209            is_updating_area = TRUE;
    210          }
    211          
    212          /* update index table, and area table if necessary */
    213          STATUS INDEX_Update_Commit() {
    214            AREA area;
    215            BOOL area_reclaim = FALSE;
    216            STATUS ret = STATUS_SUCCESS;
    217          
    218            PHY_BLOCK updating_logical_block;
    219            PHY_BLOCK updating_physical_block;
    220            
    221            ERASE_COUNT updating_block_ec;
    222          
    223            
    224            do {
    225              if (is_updating_area == TRUE) {
    226                updating_logical_block = index_table.area_update_plr.area_updating_logical_block;
    227                updating_physical_block = index_table.area_update_plr.area_updating_physical_block;
    228                updating_block_ec = index_table.area_update_plr.area_updating_block_ec;
    229          
    230                /* update area table, the 2nd-level index table */
    231                if (AREA_IsFull(updating_logical_block) == TRUE) {//判断某个LEB所在area的area block中的页是否用完
    232                  /* update area table in another new area table block.
    233                   * the new block is only valid after writing index table, so no PLR
    234                   * issue between writing these two blocks.*/
    235                  
    236                  //jsjpenn        
    237                  //原来的逻辑是：如果某个area的area block中的页用完时，从FBT中得到一个PEB，然后修改Index table中
    238                  //中的idnex_table.area_index_table[]
    239                  //为了保证各个area block的PEB不变，从而方便恢复，改为直接对原PEB进行物理擦除，且不修改index table        
    240                  area = AREA_INDEX(updating_logical_block);
    241                  ret=MTD_Erase(index_table.area_index_table[area]);//直接对原PEB进行物理擦除        
    242               
    243                  if (ret == STATUS_SUCCESS) {
    244                    /* update info of area index table */
    245                    //原来的逻辑：将原area table的PEB放回到FBT中
    246                    //更新index_table.area_index_table[]和index_table.area_index_ect[]
    247                    //INDEX_Update_AreaReclaim(area, new_area_block, new_area_ec);
    248                    area_reclaim = TRUE;
    249                  }else{
    250                    uart_printf("***%s***: Error: erase %d area block PEB fail\r\n",__func__,area);          
    251                  }
    252                  
    253                 //jsjpennend   
    254                  
    255                } else {
    256                  /* update index table with area update info for PLR.
    257                   * PLR: get the area update info from index table, and check the
    258                   *      area table if need to update due to PL.*/
    259                  ret = index_update();
    260                }
    261                if (ret == STATUS_SUCCESS) {
    262                  /* write area block */
    263                  //更新MAPII映射，并将更新后的映射写入对应的area block PEB中
    264                  ret = AREA_Update(updating_logical_block, updating_physical_block, updating_block_ec);
    265                  if (ret == STATUS_SUCCESS && area_reclaim == TRUE) {
    266                    /* update index later than area, if area block reclaimed */
    267                    ret = index_update();
    268                  }
    269                }
    270                if (ret == STATUS_SUCCESS) {
    271                  /* CLEAR the area update flag */
    272                  is_updating_area = FALSE;
    273                }
    274              } else {
    275                /* only update index table */
    276                ret = index_update();
    277              }
    278            } while (ret == STATUS_BADBLOCK);
    279            return ret;
    280          }
    281          
    282          void INDEX_FreeBlock_GetMaxECBlock(PHY_BLOCK* physical_block,
    283                                             ERASE_COUNT* block_ec) {
    284            UINT32 i;
    285            
    286            
    287            //jsjpenn
    288            UINT32 j;
    289            UINT32 judge=0;
    290            
    291            for (i = FREE_BLOCK_COUNT - 1; i > 0; i--) {
    292              if (index_table.free_block_ect[i] != INVALID_EC) {
    293                *physical_block = index_table.free_block_table[i];
    294                *block_ec = index_table.free_block_ect[i];
    295                
    296              }
    297            }
    298          
    299            return;
    300          }
    301          
    302          void INDEX_FreeBlock_SwapMaxECBlock(PHY_BLOCK min_ec_block, ERASE_COUNT min_ec) {
    303            UINT32 i;
    304          
    305            /* swap for SWL:
    306             * - find the max ec good block in free block,
    307             * - re-sort and inset the min ec block
    308             */
    309          
    310            /* GET the max ec good block in the sorted free block */
    311            for (i = FREE_BLOCK_COUNT - 1; i > 0; i--) {
    312              if (index_table.free_block_ect[i] != INVALID_EC) {
    313                break;
    314              }
    315            }
    316          
    317            if (index_table.free_block_ect[i] != INVALID_EC
    318                && index_table.free_block_ect[i] > min_ec
    319                && index_table.free_block_ect[i] - min_ec > STATIC_WL_THRESHOLD) {
    320              /* insert the min ec block to sorted free block table,
    321               * continue to scan the free block table to head.
    322               */
    323              for (i = i - 1; i > 0; i--) {
    324                if (index_table.free_block_ect[i] > min_ec) {
    325                  index_table.free_block_table[i + 1] = index_table.free_block_table[i];
    326                  index_table.free_block_ect[i + 1] = index_table.free_block_ect[i];
    327                } else {
    328                  /* insert the min ec block in current position */
    329                  index_table.free_block_table[i + 1] = min_ec_block;
    330                  index_table.free_block_ect[i + 1] = min_ec;
    331          
    332                  break;
    333                }
    334              }
    335              /* an special case due to i is unsigned char */
    336              if (i == 0) {
    337                if (index_table.free_block_ect[0] > min_ec) {
    338                  index_table.free_block_table[1] = index_table.free_block_table[0];
    339                  index_table.free_block_ect[1] = index_table.free_block_ect[0];
    340          
    341                  index_table.free_block_table[0] = min_ec_block;
    342                  index_table.free_block_ect[0] = min_ec;
    343                } else {
    344                  /* insert the min ec block in current position */
    345                  index_table.free_block_table[1] = min_ec_block;
    346                  index_table.free_block_ect[1] = min_ec;
    347                }
    348              }
    349            }
    350          }
    351          
    352          /* the EC of the free block in FBT:
    353           * MSB: set when read/program fail, reset if erased successfully
    354           * when erasing a block in FBT failed, just discard it, and get a new block
    355           * from IBT! If none in IBT, discard the bad, and get another in FBT.
    356           */
    357          STATUS INDEX_FreeBlock_Get(DIE_INDEX die, PHY_BLOCK* block, ERASE_COUNT* ec) {
    358            STATUS ret;
    359            UINT32 i;
    360          
    361            die = die % TOTAL_DIE_COUNT;//0
    362            
    363            uart_printf("**%s**:called\r\n", __func__);
    364            
    365            do {
    366              for (i = 0; i < FREE_BLOCK_COUNT; i++) {//125
    367                /* get new block at the head of free block table,
    368                 * whose ec is min, and in the same die. */
    369                if (index_table.free_block_table[i] == INVALID_BLOCK) {
    370                  i = FREE_BLOCK_COUNT;
    371                  break;
    372                } else if ((index_table.free_block_table[i] % TOTAL_DIE_COUNT) == die) {
    373                  *block = index_table.free_block_table[i];
    374                  break;
    375                }
    376              }
    377              //for循环遍历所有free block后，遇到第一个无效块后，返回i=FREE_BLOCK_COUNT
    378              if (i == FREE_BLOCK_COUNT) {
    379                /* can not find the block in the same die, get another */
    380                i = 0;
    381                *block = index_table.free_block_table[0];
    382              }
    383              //返回同一个die中的FBT的第一项，即EC最小的free block 
    384              if (*block != INVALID_BLOCK) {
    385                ASSERT(i < FREE_BLOCK_COUNT);
    386          
    387                /* no background erase. Erase block before using it. Most of erase
    388                 * would happen in background reclaim.
    389                 */
    390                ret = MTD_Erase(*block);//真正的擦除从FBT中返回的EC最小的物理块 
    391                //jsjpenn
    392                if(ret==STATUS_MTDEraseReturnFail){
    393                  uart_printf("*%s*: MTD Erase PEB %d Return Fail\r\n", __func__,*block);        
    394                }else{
    395                  uart_printf("*%s*: MTD Erase PEB %d Return ok\r\n", __func__,*block);
    396                }
    397                
    398              } else {
    399                ret = STATUS_TOOMANY_BADBLOCK;
    400              }
    401          
    402              if (ret != STATUS_SUCCESS && ret!=STATUS_MTDEraseReturnFail) {
    403                /* discard and log the bad block */
    404                ANCHOR_LogBadBlock(*block);
    405              }
    406          
    407              if (ret == STATUS_SUCCESS) {
    408                /* increase erase count of the new free block */
    409                *ec = index_table.free_block_ect[i] + 1;
    410              }
    411              //将FBT各项前移    
    412              if (ret != STATUS_TOOMANY_BADBLOCK) {
    413                /* move forward all other blocks, discard current block in FBT */
    414          
    415                for (; i < FREE_BLOCK_COUNT - 1; i++) {
    416                  index_table.free_block_table[i] = index_table.free_block_table[i + 1];
    417                  index_table.free_block_ect[i] = index_table.free_block_ect[i + 1];
    418                }
    419                /* fill the last free block entry with invalid block info */
    420                ASSERT(i == FREE_BLOCK_COUNT - 1);
    421                index_table.free_block_table[i] = INVALID_BLOCK;
    422                index_table.free_block_ect[i] = INVALID_EC;
    423              }
    424              /* if not get a free block, and there is good block left (e.g. not
    425               * too many bad block generated.), try again. */
    426            } while (ret != STATUS_SUCCESS && ret != STATUS_TOOMANY_BADBLOCK
    427                && ret != STATUS_SimulatedPowerLoss);//ret只要等于三个当中其中某一个值就停止循环
    428          
    429            return ret;
    430          }
    431          
    432          void INDEX_FreeBlock_Put(PHY_BLOCK dirty_block, ERASE_COUNT dirty_block_ec) {
    433            UINT32 i;
    434            
    435             //将物理块加入FBT (按EC递增排序) 
    436             //由于从free block往外分配时会先检查是否是坏块，所以不必再此检查是否为坏块  
    437            /* the last item of FBT will be discarded to insert the new free block */
    438            for (i = FREE_BLOCK_COUNT - 2; i > 0; i--) {
    439              /* search the max ec block less than dirty_block_ec */
    440              if (index_table.free_block_ect[i] > dirty_block_ec) {
    441                index_table.free_block_table[i + 1] = index_table.free_block_table[i];
    442                index_table.free_block_ect[i + 1] = index_table.free_block_ect[i];
    443              } else {
    444                break;
    445              }
    446            }
    447            /* insert new free block at the position of i+1, or at the beginning */
    448            if (i > 0) {
    449              index_table.free_block_table[i + 1] = dirty_block;
    450              index_table.free_block_ect[i + 1] = dirty_block_ec;
    451            } else {
    452              ASSERT(i == 0);
    453              if (index_table.free_block_ect[0] > dirty_block_ec) {
    454                index_table.free_block_table[1] = index_table.free_block_table[0];
    455                index_table.free_block_ect[1] = index_table.free_block_ect[0];
    456                index_table.free_block_table[0] = dirty_block;
    457                index_table.free_block_ect[0] = dirty_block_ec;
    458              } else {
    459                index_table.free_block_table[1] = dirty_block;
    460                index_table.free_block_ect[1] = dirty_block_ec;
    461              }
    462            }  
    463          }
    464          
    465          
    466          //jsjpenn  
    467          
    468          STATUS index_update() {//为了能在ubi_area.c中调用index_update()
    469            //ERASE_COUNT ec;
    470            //PHY_BLOCK free_block;
    471            STATUS ret = STATUS_SUCCESS;
    472          
    473            /* Reclaim and PLR:
    474             *
    475             * If area block is updated successfully, its data is valid, and
    476             * mismatch with index table. So, a PLR info is required in index table.
    477             *
    478             * Process:
    479             * - find the new block, and log PLR info to cfg table.
    480             *   PLR: find the PLR info in cfg table, try to read
    481             *        index table in new block. If failed, read the table
    482             *        still from the old block. Omit the latest reclaim
    483             *        log, and start another reclaim. The new block is still
    484             *        a free block in FBT, neither used, nor lost. Only need
    485             *        to do another erase before get it, and the EC is not
    486             *        updated, but it is not a big issue due to few PL happened.
    487             *        We just guartee the integrity and functionality of system.
    488             * - write index table to new block, with the updated free table
    489             *   and its ECT.
    490             *   PLR: nothing to do. The new block is integrity now.
    491             */
    492            if (index_next_page == PAGE_PER_PHY_BLOCK) {
    493              /* log reclaim in cfg table */
    494              
    495              //jsjpenn        
    496              //原来的逻辑是：如果index block中的页用完时，从FBT中得到一个PEB，然后修改anchor table中对应的index table相应变量
    497              //为了保证各个index block的PEB不变，从而方便恢复，改为直接对原PEB进行物理擦除，且不修改anchor table  
    498                     
    499              //ret = INDEX_FreeBlock_Get(index_block, &free_block, &ec);
    500               ret=MTD_Erase(index_block);
    501            
    502          
    503              if (ret == STATUS_SUCCESS) {
    504               
    505                index_next_page = 0;
    506                
    507                index_block_ec++;
    508              }else{
    509                uart_printf("***%s***: Error: erase index block PEB fail\r\n",__func__);
    510              }    
    511             //jsjpennend 
    512              
    513            }
    514          
    515            if (ret == STATUS_SUCCESS) {
    516              /* one page write in index block, NO PLR issue */
    517              ret = TABLE_Write(index_block, index_next_page, &index_table);
    518            }
    519          
    520            if (ret == STATUS_SUCCESS) {
    521              index_next_page++;
    522            } else if (ret == STATUS_BADBLOCK) {
    523              /* bad block, set the next page offset to toggle index block reclaim. */
    524              index_next_page = PAGE_PER_PHY_BLOCK;
    525              /* discard the bad block */
    526              index_block_ec = INVALID_EC;
    527            }
    528            return ret;
    529          }
    530          
    531          //jsjpenn
    532          STATUS UBI_INDEX_table_store(){
    533            
    534            STATUS ret;
    535            LOG_BLOCK block_to_write=55;//UBI_reserved_START_BLOCK =55;
    536            PAGE_OFF page_to_write=16;//写在16个area table之后，即第16页
    537            
    538            PHY_BLOCK block;    
    539            block=AREA_GetBlock(block_to_write);//index table写入的物理块号
    540            
    541            ret=UBI_Write(block_to_write, page_to_write, &index_table, NULL, FALSE);
    542            
    543             if(ret == STATUS_SUCCESS) {
    544              uart_printf("%s: Write index table to %d PEB ok\r\n",__func__,block); //PEB=62   
    545            }
    546            
    547            return ret;
    548          }
    549          
    550          
    551          UINT8 g_indextable_sign;//全局变量
    552          //保存的index table信息        
    553          PHY_BLOCK g_old_index_block;//全局变量
    554          UINT32 g_old_index_block_ec;//全局变量
    555          
    556          STATUS UBI_INDEX_table_restore(){
    557            STATUS ret;
    558            LOG_BLOCK block_stored_UBI=55;//UBI_reserved_START_BLOCK =55; 
    559            PAGE_OFF page_stored_INDEX=16;//保存的index table
    560            PAGE_OFF page_stored_ANCHOR=17;//anchor table写在index table之后，即第17页
    561            
    562            //保存的index table信息        
    563            PHY_BLOCK old_index_block;
    564            //现有的index table信息
    565            PHY_BLOCK new_index_block; 
    566            
    567            PHY_BLOCK storePEB;   
    568            storePEB=AREA_GetBlock(block_stored_UBI);//UBI table写入的物理块号
    569            
    570            //先将保存的index table读到临时变量中 
    571            INDEX_TABLE tem_index_table;  
    572            ret =UBI_Read(block_stored_UBI, page_stored_INDEX, &tem_index_table, NULL);//读LEB
    573            if(ret == STATUS_SUCCESS){     
    574              uart_printf("%s: Read stored index table from %d PEB ok\r\n",__func__,storePEB);    
    575            }
    576            
    577            //先将保存的anchor table读到临时变量中  
    578            ANCHOR_TABLE tem_anchor_table;
    579            ret=UBI_Read(block_stored_UBI, page_stored_ANCHOR, &tem_anchor_table, NULL);
    580            if(ret == STATUS_SUCCESS){     
    581              uart_printf("%s: Read stored anchor table from %d PEB ok\r\n",__func__,storePEB);    
    582            }
    583              
    584            //保证index table block PEB不变 
    585            old_index_block=tem_anchor_table.index_new_block; //PEB 
    586            new_index_block=anchor_table.index_new_block;//PEB
    587            
    588            uart_printf("%s: old_index_block=%d\r\n",__func__,old_index_block);
    589            uart_printf("%s: new_index_block=%d\r\n",__func__,new_index_block);
    590            uart_printf("%s: index_block=%d\r\n",__func__,index_block);//全局变量
    591            
    592            if(old_index_block==new_index_block && old_index_block==index_block){//全局变量index_block
    593             g_indextable_sign=0; //表示index blcok没变
    594             uart_printf("%s: Index block is the same\r\n",__func__);
    595             if (index_next_page == PAGE_PER_PHY_BLOCK) {//若index block中页用完
    596               ret=MTD_Erase(old_index_block);//直接物理擦除PEB
    597               //(tem_anchor_table.index_new_ec)++;
    598               if (ret == STATUS_SUCCESS) {    
    599                 ret=TABLE_Write(old_index_block, 0, &index_table);//再将现在index table写回去 
    600                 if(ret == STATUS_SUCCESS) {        
    601                   index_next_page=1;//全局变量     
    602                   uart_printf("%s: Rewrite new index table ok\r\n",__func__);        
    603                 } 
    604                index_block_ec++;//全局变量     
    605               }else if (ret != STATUS_SUCCESS) {//todo:若出现坏块，需增加其他逻辑        
    606                ANCHOR_LogBadBlock(old_index_block);
    607                uart_printf("**%s**:ERROR-Bad index block need to do more\r\n",__func__);
    608               }
    609             }
    610             //再将保存的index table写回去    
    611             if(ret == STATUS_SUCCESS) {   
    612               ret=TABLE_Write(index_block, index_next_page, &tem_index_table);    
    613               if(ret == STATUS_SUCCESS) {
    614                uart_printf("%s: Rewrite old index table to the %d page of old index block PEB %d ok\r\n",__func__,index_next_page,old_index_block);
    615              }  
    616            }
    617             
    618           }else{
    619             //已在index_update()中保证index block PEB不变，循环使用    
    620             g_indextable_sign=1;//标记位，表示index blcok改变
    621             uart_printf("%s: Index block has changed\r\n",__func__); 
    622             g_old_index_block=old_index_block;
    623             ret=MTD_Erase(old_index_block);//直接物理擦除PEB
    624             //(tem_anchor_table.index_new_ec)++;//不用加了
    625             if (ret == STATUS_SUCCESS) {
    626              g_old_index_block_ec= tem_anchor_table.index_new_ec;
    627              ret=TABLE_Write(old_index_block, 0, &tem_index_table);//直接将保存的index table写到原index block中
    628              if(ret == STATUS_SUCCESS) {            
    629                uart_printf("%s: Rewrite old index table to old index block ok\r\n",__func__);       
    630              } 
    631                   
    632             }else if (ret != STATUS_SUCCESS) {//若出现坏块，需增加其他逻辑        
    633               ANCHOR_LogBadBlock(old_index_block);
    634               uart_printf("**%s**:ERROR-Bad index block need to do more\r\n",__func__);
    635             }
    636           
    637            }
    638           
    639           //在恢复area table时保证各area block PEB没变，最多只是area block的擦除次数变化
    640           //所以在恢复index table时，直接恢复保存的index table即可
    641           
    642            //以上过程只是将保存的index table写到原index block中，但还不执行index_update()
    643            //在更新完所有UBI和FTL表后，需要先判断标记位，再从不同的位置将保存的index table读回，再执行index_update()
    644          
    645            return ret;
    646          }
    647          
    648          
    649          STATUS Truly_UBI_INDEX_table_restore(){
    650            STATUS ret= STATUS_SUCCESS;
    651            
    652            if(g_indextable_sign==1){//表示index blcok改变
    653              
    654              index_block = g_old_index_block;
    655              index_next_page = 1;
    656              index_block_ec = g_old_index_block_ec; 
    657              
    658              uart_printf("%s: Restore index table ok-changed index block\r\n",__func__); 
    659            }
    660            
    661            if(g_indextable_sign==0){//表示index blcok不变
    662              
    663              index_next_page++; 
    664              uart_printf("%s: Restore index table ok-unchanged index block\r\n",__func__);
    665            }  
    666            
    667            return ret;
    668          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   INDEX_Format
        32   -> ANCHOR_IsBadBlock
        32   -> ANCHOR_LogBadBlock
        32   -> MTD_Erase
        32   -> TABLE_Write
      24   INDEX_FreeBlock_Get
        24   -> ANCHOR_LogBadBlock
        24   -> MTD_Erase
        24   -> uart_printf
       8   INDEX_FreeBlock_GetMaxECBlock
      12   INDEX_FreeBlock_Put
      12   INDEX_FreeBlock_SwapMaxECBlock
      24   INDEX_Init
        24   -> TABLE_Read
        24   -> index_update
      16   INDEX_Update_AreaReclaim
        16   -> INDEX_FreeBlock_Put
       4   INDEX_Update_AreaUpdate
      32   INDEX_Update_Commit
        32   -> AREA_IsFull
        32   -> AREA_Update
        32   -> MTD_Erase
        32   -> index_update
        32   -> uart_printf
       8   Truly_UBI_INDEX_table_restore
         8   -> uart_printf
    4120   UBI_INDEX_table_restore
      4120   -> ANCHOR_LogBadBlock
      4120   -> AREA_GetBlock
      4120   -> MTD_Erase
      4120   -> TABLE_Write
      4120   -> UBI_Read
      4120   -> uart_printf
      24   UBI_INDEX_table_store
        24   -> AREA_GetBlock
        24   -> UBI_Write
        24   -> uart_printf
       8   index_update
         8   -> MTD_Erase
         8   -> TABLE_Write
         8   -> uart_printf
      40   printint
        40   -> UartWrite
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      56   printuint
        56   -> UartWrite
        56 __aeabi_uidiv
        56 __aeabi_uidivmod
      40   uart_printf
        40   -> UartWrite
        40   -> printint
        40   -> printuint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable3
       4  ??DataTable4
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       8  ?_0
      48  ?_1
      28  ?_10
      24  ?_11
      32  ?_12
      36  ?_13
      48  ?_14
      76  ?_15
      32  ?_16
      52  ?_17
      52  ?_18
      52  ?_19
      16  ?_2
      40  ?_3
      36  ?_4
      48  ?_5
      40  ?_6
      48  ?_7
      48  ?_8
      28  ?_9
     316  INDEX_Format
     326  INDEX_FreeBlock_Get
      66  INDEX_FreeBlock_GetMaxECBlock
     160  INDEX_FreeBlock_Put
     240  INDEX_FreeBlock_SwapMaxECBlock
     174  INDEX_Init
      58  INDEX_Update_AreaReclaim
      52  INDEX_Update_AreaUpdate
     164  INDEX_Update_Commit
      76  Truly_UBI_INDEX_table_restore
     404  UBI_INDEX_table_restore
      60  UBI_INDEX_table_store
      20  digits
      20  digits
       1  g_indextable_sign
       4  g_old_index_block
       4  g_old_index_block_ec
       4  index_block
       4  index_block_ec
       4  index_next_page
    2048  index_table
     130  index_update
       4  is_updating_area
     104  printint
      64  printuint
     210  uart_printf
     136  -- Other

 
 2 073 bytes in section .bss
    40 bytes in section .data
   928 bytes in section .rodata
 2 856 bytes in section .text
 
 2 856 bytes of CODE  memory
   928 bytes of CONST memory
 2 113 bytes of DATA  memory

Errors: none
Warnings: 7
