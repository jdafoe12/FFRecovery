###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.5.9725/W32 for ARM        26/Oct/2022  20:51:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\core\ftl\ftl_api.c
#    Command line =  
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\core\ftl\ftl_api.c" -D BOOT_LEVEL_2 -lcN
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List" -o
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\prj\iar\..\..\"
#        -I "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\bsp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\csp\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\lib\" -I
#        "C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\..\..\sys\lpc313x\usb\" --cpu_mode thumb -Ol
#        --use_c++_inline
#    List file    =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\List\ftl_api.lst
#    Object file  =  
#        C:\Users\niusenc\Desktop\recovery -
#        Copy\nsac-hiftl\prj\iar\Debug\Obj\ftl_api.o
#
###############################################################################

C:\Users\niusenc\Desktop\recovery - Copy\nsac-hiftl\core\ftl\ftl_api.c
      1          /*********************************************************
      2           * Module name: ftl_api.c
      3           *
      4           * Copyright 2010, 2011. All Rights Reserved, Crane Chu.
      5           *
      6           * This file is part of OpenNFM.
      7           *
      8           * OpenNFM is free software: you can redistribute it and/or 
      9           * modify it under the terms of the GNU General Public 
     10           * License as published by the Free Software Foundation, 
     11           * either version 3 of the License, or (at your option) any 
     12           * later version.
     13           * 
     14           * OpenNFM is distributed in the hope that it will be useful,
     15           * but WITHOUT ANY WARRANTY; without even the implied 
     16           * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     17           * PURPOSE. See the GNU General Public License for more 
     18           * details.
     19           *
     20           * You should have received a copy of the GNU General Public 
     21           * License along with OpenNFM. If not, see 
     22           * <http://www.gnu.org/licenses/>.
     23           *
     24           * First written on 2010-01-01 by cranechu@gmail.com
     25           *
     26           * Module Description:
     27           *    FTL APIs.
     28           *
     29           *********************************************************/
     30          
     31          #include <core\inc\cmn.h>
     32          #include <core\inc\ftl.h>
     33          #include <core\inc\ubi.h>
     34          #include <core\inc\mtd.h>
     35          #include <sys\sys.h>
     36          #include "ftl_inc.h"
     37          #include <core\inc\buf.h>
     38          
     39          
     40          /* Advanced Page Mapping FTL:
     41           * - Block Dirty Table: LOG_BLOCK 0, cache all
     42           * - ROOT Table: LOG_BLOCK 1, cache all. point to journal blocks.
     43           * - Page Mapping Table: LOG_BLOCK 2~N, cache x pages with LRU algo.
     44           * - DATA Journal: commit
     45           * - Init: read BDT, ROOT, PMT, Journal info, ...
     46           * - Reclaim
     47           * - Meta Data Page: in last page in PMT blocks and data blocks.
     48           * - choose journal block on erase and write, according to die index
     49           *
     50           * TODO: advanced features:
     51           * - sanitizing
     52           * - bg erase
     53           * - check wp/trim, ...
     54           */
     55             
     56           //jsjpenn
     57          UINT32 g_LBAnum;//逻辑地址I总数 
     58             
     59          
     60          STATUS FTL_Format() {
     61              
     62            STATUS ret;    
     63            ret = UBI_Format();
     64            if (ret == STATUS_SUCCESS) {
     65              ret = UBI_Init();
     66            }
     67          
     68            if (ret == STATUS_SUCCESS) {
     69              ret = DATA_Format();
     70            }
     71          
     72            if (ret == STATUS_SUCCESS) {
     73              ret = HDI_Format();
     74            }
     75          
     76            if (ret == STATUS_SUCCESS) {
     77              ret = PMT_Format();
     78            }
     79          
     80            if (ret == STATUS_SUCCESS) {
     81              ret = BDT_Format();
     82            }
     83          
     84            if (ret == STATUS_SUCCESS) {
     85              ret = ROOT_Format();
     86            }
     87          
     88            return ret;
     89          }
     90          
     91          STATUS FTL_Init() {
     92            STATUS ret;
     93          
     94            ret = UBI_Init();
     95            if (ret == STATUS_SUCCESS) {
     96              /* scan tables on UBI, and copy to RAM */
     97              ret = ROOT_Init();
     98            }
     99          
    100            if (ret == STATUS_SUCCESS) {
    101              ret = BDT_Init();
    102            }
    103          
    104            if (ret == STATUS_SUCCESS) {
    105              ret = PMT_Init();
    106            }
    107          
    108            if (ret == STATUS_SUCCESS) {
    109              ret = HDI_Init();
    110            }
    111              
    112            //jsjpenn在状态2中更新hot 与cold日志块
    113            if (ret == STATUS_SUCCESS && g_state==2) {
    114              JOURNAL_ADDR* journal;
    115              JOURNAL_ADDR* exclude_journal;
    116              journal = root_table.hot_journal;
    117              exclude_journal = root_table.cold_journal;
    118              UINT32 hotblock, coldblock;
    119              hotblock = PM_NODE_BLOCK(journal[0]);
    120              coldblock= PM_NODE_BLOCK(exclude_journal[0]);
    121              //uart_printf("%s: Before change: hot journal blcok=%d,cold journal blcok=%d\r\n",__func__,hotblock,coldblock);
    122              
    123              ret = DATA_Reclaim(TRUE);//更新hot日志块
    124              if (ret == STATUS_SUCCESS) {
    125                ret = DATA_Reclaim(FALSE);//更新cold日志块
    126                if (ret == STATUS_SUCCESS) {
    127                  ret = DATA_Commit();//更新FTL的各个表到flash上
    128                  if (ret == STATUS_SUCCESS) {
    129                    hotblock = PM_NODE_BLOCK(journal[0]);
    130                    coldblock= PM_NODE_BLOCK(exclude_journal[0]);  
    131                    //uart_printf("%s: After change: hot journal blcok=%d,cold journal blcok=%d,\r\n",__func__,hotblock,coldblock);        
    132                  }
    133               }
    134              }  
    135            }
    136            
    137            //jsjpenn
    138            //只在状态1中执行即可，状态2时从新的日志块开始，且内存中的映射已清空
    139           if (g_state==1) {
    140             
    141            if (ret == STATUS_SUCCESS) { 
    142           
    143              ret = DATA_Replay(root_table.hot_journal);
    144            }
    145          
    146            if (ret == STATUS_SUCCESS) {
    147             
    148              ret = DATA_Replay(root_table.cold_journal);
    149            }
    150          
    151            if (ret == STATUS_SUCCESS) {
    152              /* handle reclaim PLR: start reclaim again. Some data should
    153               * be written in the same place, so just rewrite same data in the
    154               * same page regardless this page is written or not. */
    155          
    156              /* check if hot journal blocks are full */
    157              if (DATA_IsFull(TRUE) == TRUE) {
    158                ret = DATA_Reclaim(TRUE);
    159                if (ret == STATUS_SUCCESS) {
    160                  ret = DATA_Commit();
    161                }
    162              }
    163          
    164              /* check if cold journal blocks are full */
    165              if (DATA_IsFull(FALSE) == TRUE) {
    166                ret = DATA_Reclaim(FALSE);
    167                if (ret == STATUS_SUCCESS) {
    168                  ret = DATA_Commit();
    169                }
    170              }
    171            }
    172            
    173            
    174           }//jsjpennend
    175           
    176           
    177            return ret;
    178          }
    179          
    180          
    181          int tag=0;
    182          
    183          STATUS FTL_Write(PGADDR addr, void* buffer) {
    184            STATUS ret;
    185            //uart_printf("%s: LBA=%d\r\n",__func__,addr); 
    186             
    187            //jsjpenn 判断是否需要改变状态g_LBAnum=240345
    188            //if(addr==g_LBAnum-100){//240245 linux判断扇区数=240245*4=960980 
    189            
    190          //    if(addr>g_LBAnum){
    191          //      tag++;
    192          //      uart_printf("***%s***: tag=%d\r\n",__func__,tag);
    193          //      
    194          //      if(tag>1){//在格式化文件系统时会触发一次
    195          //        g_ReceiveCommandNum++;
    196          //        
    197          //        //Lock: sudo dd if=/dev/zero of=/dev/sdb bs=512 count=1 seek=961384
    198          //        if(addr==240346){          
    199          //          //if(g_ReceiveCommandNum==1 && g_state==1){      
    200          //            ret=FTL_UBI_StartLockImage();//过程1
    201          //            if(ret == STATUS_SUCCESS) {        
    202          //             g_state++;        
    203          //             uart_printf("%s: State 1 and process 1 done, we have entered state 2, start to test malware\r\n",__func__);        
    204          //             ret=STATUS_SUCCESS;//不需要重启
    205          //             return ret;
    206          //            }
    207          //          //}         
    208          //        }
    209          //        
    210          //       //Recover: sudo dd if=/dev/zero of=/dev/sdb bs=512 count=1 seek=961388  
    211          //       if(addr==240347){
    212          //         //if(g_ReceiveCommandNum>=2){
    213          //          ret=FTL_UBI_RestoreImage();//过程2
    214          //          if(ret == STATUS_SUCCESS) {
    215          //           uart_printf("%s: Restore the image ok, the %d time to enter state 2,\r\n",__func__,g_ReceiveCommandNum);
    216          //           ret=STATUS_Remount;             
    217          //           return ret;
    218          //          }
    219          //        //}         
    220          //       }
    221          //       return ret=STATUS_SUCCESS;   
    222          //        
    223          //      }      
    224          //      
    225          //    }
    226               
    227            
    228              /****************************nc test****************/
    229              if(addr==237846){ //951384         
    230                    //if(g_ReceiveCommandNum==1 && g_state==1){      
    231                      ret=FTL_UBI_StartLockImage();//过程1
    232                      if(ret == STATUS_SUCCESS) {        
    233                       g_state++;        
    234                       uart_printf("%s: State 1 and process 1 done, we have entered state 2, start to test malware\r\n",__func__);        
    235                       ret=STATUS_SUCCESS;//不需要重启        
    236                       return ret;
    237                      }
    238                      
    239                      else {
    240                        uart_printf("state 1 failed\n");
    241                      }
    242                    //}         
    243                  }
    244              
    245              if(addr==237847){ //951388
    246                   //if(g_ReceiveCommandNum>=2){
    247                    ret=FTL_UBI_RestoreImage();//过程2
    248                    if(ret == STATUS_SUCCESS) {
    249                     uart_printf("%s: Restore the image ok, the %d time to enter state 2,\r\n",__func__,g_ReceiveCommandNum);
    250                     ret=STATUS_Remount;             
    251                     return ret;
    252                    }
    253                    else {
    254                      uart_printf("state 2 failed\n");
    255                    }
    256                  //}         
    257                 }
    258              
    259              /****************************nc test****************/
    260              
    261              // JD
    262              if(addr==237848) { // 951392
    263                if(ftl_read_state == 0) {
    264                  ret = STATUS_SUCCESS;
    265                  ftl_read_state = 1;
    266                  uart_printf("%Entered read state: d\n - Recovery", ftl_read_state);
    267                }
    268                else {
    269                  ret = STATUS_SUCCESS;
    270                  ftl_read_state = 0;
    271                  uart_printf("Entered read state: %d - Normal\n", ftl_read_state);
    272                  
    273                }
    274                return ret;
    275              }
    276              
    277              // JD end
    278              
    279            BOOL is_hot = HDI_IsHotPage(addr);  
    280             
    281            ret = DATA_Write(addr, buffer, is_hot);
    282            
    283            if (ret == STATUS_SUCCESS) {
    284              if (DATA_IsFull(is_hot) == TRUE) {
    285                ret = DATA_Reclaim(is_hot);
    286                if (ret == STATUS_SUCCESS) {
    287                  ret = DATA_Commit();
    288                }
    289              }
    290            }
    291            return ret;
    292          }
    293          
    294          STATUS FTL_Read(PGADDR addr, void* buffer) {
    295            LOG_BLOCK block;
    296            PAGE_OFF page;
    297            STATUS ret;
    298            
    299            //uart_printf("%s: LBA=%d\r\n",__func__,addr); 
    300            
    301            ret = PMT_Search(addr, &block, &page);
    302            //uart_printf("block: %d page: %d\n", block, page);
    303            if (ret == STATUS_SUCCESS) {
    304              ret = UBI_Read(block, page, buffer, NULL);
    305            }
    306            return ret;
    307          }
    308          
    309          STATUS FTL_Trim(PGADDR start, PGADDR end) {
    310            PGADDR addr;
    311            STATUS ret = STATUS_SUCCESS;
    312          
    313            for (addr = start; addr <= end; addr++) {
    314              ret = FTL_Write(addr, NULL);
    315              if (ret != STATUS_SUCCESS) {
    316                break;
    317              }
    318            }
    319          
    320            return ret;
    321          }
    322          
    323          STATUS FTL_SetWP(PGADDR laddr, BOOL enabled) {
    324            return STATUS_FAILURE;
    325          }
    326          
    327          BOOL FTL_CheckWP(PGADDR laddr) {
    328            return FALSE;
    329          }
    330          
    331          STATUS FTL_BgTasks() {
    332            return STATUS_SUCCESS;
    333          }
    334          
    335          PGADDR FTL_Capacity() {
    336            LOG_BLOCK block;
    337          
    338            block = UBI_Capacity;//3991
    339            block -= JOURNAL_BLOCK_COUNT; /* data hot journal *///1
    340            block -= JOURNAL_BLOCK_COUNT; /* data cold journal *///1
    341            block -= JOURNAL_BLOCK_COUNT; /* data reclaim journal *///1
    342            block -= PMT_BLOCK_COUNT; /* pmt blocks *///40
    343            block -= 2; /* bdt blocks */
    344            block -= 2; /* root blocks */
    345            block -= 2; /* hdi reserved */
    346            
    347            //jsjpenn
    348            block -= 8;//PMTRESORE_START_BLOCK
    349            block -= 1;//UBI_reserved_START_BLOCK
    350            block -=1;//FTL_reserved_START_BLOCK
    351            
    352            block -= block / 100 * OVER_PROVISION_RATE; /* over provision */
    353              
    354            //jsjpenn
    355             g_LBAnum=block * (PAGE_PER_PHY_BLOCK - 1);//逻辑地址I总数=3815*63=240345 
    356             
    357            /* last page in every block is reserved for meta data collection */
    358            return g_LBAnum;//返回逻辑地址I总数
    359          }
    360          
    361          STATUS FTL_Flush() {
    362            STATUS ret= STATUS_SUCCESS;
    363              
    364           
    365            if (ret == STATUS_SUCCESS) {
    366              ret = UBI_Flush();
    367            }
    368          
    369            if (ret == STATUS_SUCCESS) {
    370              
    371            }
    372          
    373            return ret;
    374          }
    375          
    376          
    377          //jsjpenn
    378          STATUS FTL_UBI_StartLockImage(){
    379          
    380            STATUS ret= STATUS_SUCCESS;  
    381            //uart_printf("%s: Start to lock image\r\n",__func__);   
    382            
    383             //wpy 
    384            UINT32 i;
    385            LOG_BLOCK block =PMTRESORE_START_BLOCK;//46
    386            
    387           //wpy
    388            for(i=0;i<PMTRESORE_BLOCK_COUNT+FTL_reserved_BLOCK_COUNT;i++){ // MAPII stored in 55-71. Should these be erased?
    389              if (ret == STATUS_SUCCESS) {
    390                ret = UBI_Erase(block, block);//擦除存储的前一个状态的各种表 46-54，UBI层不变
    391              }
    392              block++;
    393            }
    394            
    395            //1.更新hot、cold日志块，保证image与malware不共用块
    396            JOURNAL_ADDR* journal;
    397            JOURNAL_ADDR* exclude_journal;
    398            journal = root_table.hot_journal;
    399            exclude_journal = root_table.cold_journal;
    400           
    401            //将日志块中的MAPI更新到flash上的PMT块中，保证SRAM中的映射更新到了flash上
    402            if (ret == STATUS_SUCCESS) {
    403              ret = DATA_Replay(journal);
    404            }
    405            if (ret == STATUS_SUCCESS) {
    406              ret = DATA_Replay(exclude_journal);
    407            }  
    408            
    409           
    410            
    411            ret = DATA_Reclaim(TRUE);//更新hot日志块
    412            if (ret == STATUS_SUCCESS) {
    413              ret = DATA_Reclaim(FALSE);//更新cold日志块
    414              if (ret == STATUS_SUCCESS) {
    415                ret = DATA_Commit();//此韩式真正实现将FTL的各个表更新到flash上
    416                if (ret == STATUS_SUCCESS) {
    417                       
    418                }
    419              }
    420            }  
    421             
    422            /*  
    423            //2.保存UBI各种表结构
    424            //由于改变了UBI_Erase()中的逻辑，MAPII不会改变（除非遇到坏块和使用均衡）
    425            //因此不用保存UBI的各个表
    426            ret=UBI_table_store();  
    427            if(ret == STATUS_SUCCESS) {    
    428              uart_printf("%s: Write all the UBI tables ok\r\n",__func__);
    429            }*/
    430            
    431            
    432            //3.保存FTL各种表结构
    433            ret=FTL_table_store();  
    434            if(ret == STATUS_SUCCESS) {    
    435              //uart_printf("%s: Write all the FTL tables ok\r\n",__func__);     
    436            }
    437            
    438            return ret;
    439          }
    440          
    441          //2 保存UBI各种表结构
    442          STATUS UBI_table_store(){
    443          
    444            STATUS ret;
    445            
    446            //1.保存AREA table，即MAP II
    447              ret=UBI_MAPII_store();
    448          
    449           //2.保存INDEX table
    450             if(ret == STATUS_SUCCESS) {
    451              ret=UBI_INDEX_table_store();    
    452            }    
    453              
    454           //3.保存ANCHOR table 
    455             if(ret == STATUS_SUCCESS) {
    456               ret=UBI_ANCHOR_table_store(); 
    457             }
    458             
    459            return ret;
    460          }
    461          
    462          
    463          
    464          //3 保存FTL各种表结构
    465          STATUS FTL_table_store(){
    466             
    467            STATUS ret;
    468            
    469            //1.保存HDI hash table
    470            ret=FTL_HDI_hash_table_store();
    471            
    472           //2.保存MAPI
    473           if(ret == STATUS_SUCCESS) {
    474            FTL_MAPI_store();
    475           }  
    476            
    477           //3.保存BDT table
    478           if(ret == STATUS_SUCCESS) {
    479            FTL_BDT_table_store();
    480           }
    481            
    482           //4.保存ROOT table
    483           if(ret == STATUS_SUCCESS) {
    484            FTL_ROOT_table_store();
    485           } 
    486             
    487            return ret;  
    488          }
    489          
    490          
    491          //3.2保存MAPI
    492          STATUS FTL_MAPI_store(){  
    493            STATUS ret = STATUS_SUCCESS;
    494            UINT32 iClusterNum;//总簇数
    495            UINT32 i,j,k;  
    496            
    497            LOG_BLOCK block_to_write;
    498            PAGE_OFF page_to_write;
    499            
    500            LOG_BLOCK block;
    501            PAGE_OFF page;
    502            
    503            PM_NODE_ADDR iPM_NODE[PM_PER_NODE];//512
    504            PM_NODE_ADDR* cache_addr = NULL;
    505            
    506            SPARE spare; 
    507            
    508            LOG_BLOCK LEBblock;
    509            LOG_BLOCK LEBtemp;
    510            
    511            LOG_BLOCK ValidLEBTable[4096];
    512            UINT32  ValidLEBNum=0;
    513            
    514            UINT32 judge=1;
    515            
    516                
    517            //MAPI占8块，存到逻辑II的8个LEB块中   
    518            iClusterNum=((g_LBAnum + PM_PER_NODE - 1) /  PM_PER_NODE);//总簇数    470
    519            cache_addr = &(iPM_NODE[0]);
    520            
    521            for(i=0;i<iClusterNum;i++){ // Loops 470 times
    522                  
    523                block_to_write=(i/PAGE_PER_PHY_BLOCK)+PMTRESORE_START_BLOCK;//从LEB 46块开始  46-53
    524                page_to_write=i%PAGE_PER_PHY_BLOCK;
    525               // uart_printf("block to write in MAPI store: %d page to write in MAPI Store: %d\n", block_to_write, page_to_write);
    526                
    527                block = PM_NODE_BLOCK(root_table.page_mapping_nodes[i]);
    528                //uart_printf("associated pm node block: %d\n", block);
    529                page = PM_NODE_PAGE(root_table.page_mapping_nodes[i]);
    530                //uart_printf("associated pm node page: %d\n", page);
    531                ret = UBI_Read(block, page, cache_addr, NULL);
    532                
    533                if(ret == STATUS_SUCCESS) {
    534                  spare[0]=i; //簇号     
    535                  //uart_printf("spare[0]: %d\n", spare[0]);
    536                  ret = UBI_Write(block_to_write, page_to_write, cache_addr, spare, FALSE);        
    537                }
    538                      
    539                
    540            }  
    541            
    542            
    543             return ret;  
    544          }
    545          
    546          
    547          //恢复image
    548          STATUS FTL_UBI_RestoreImage(){
    549            STATUS ret= STATUS_SUCCESS;
    550            
    551            /*
    552            //1.恢复UBI各种表结构
    553            ret=UBI_table_restore();   
    554            if(ret == STATUS_SUCCESS){    
    555              uart_printf("%s: Rewrite all the UBI tables ok\r\n",__func__);
    556            }*/
    557            
    558            //2.恢复FTL各种表结构
    559            ret=FTL_table_restore();  
    560            if(ret == STATUS_SUCCESS){    
    561             // uart_printf("%s: Rewrite all the FTL tables ok\r\n",__func__);     
    562            }
    563            
    564            /*
    565            //3.真正更新UBI各种表结构
    566            ret=Truly_UBI_table_restore();  
    567            if(ret == STATUS_SUCCESS){    
    568              uart_printf("%s: Truly restore all the UBI tables ok\r\n",__func__);     
    569            }*/
    570            
    571            /*
    572            //4.真正更新FTL各种表结构-无实际作用
    573             ret=Truly_FTL_table_restore();  
    574            if(ret == STATUS_SUCCESS){    
    575              uart_printf("%s: Truly restore all the FTL tables ok\r\n",__func__);     
    576            }*/
    577            
    578            
    579           return ret;  
    580          }
    581          
    582          
    583          STATUS UBI_table_restore(){
    584            
    585              STATUS ret;  
    586                  
    587              
    588            //1.恢复AREA table，即MAP II
    589             ret=UBI_MAPII_restore();
    590              
    591              
    592            //2.恢复INDEX table    
    593            if(ret == STATUS_SUCCESS){
    594             ret=UBI_INDEX_table_restore();    
    595            }
    596            
    597             //3.恢复ANCHOR table 
    598            if(ret == STATUS_SUCCESS){    
    599              ret=UBI_ANCHOR_table_restore(); 
    600            }
    601          
    602          
    603            return ret;  
    604          }
    605          
    606          STATUS FTL_table_restore(){
    607            
    608              STATUS ret;
    609          
    610              //1.恢复HDI hash table
    611              ret=FTL_HDI_hash_table_restore(); 
    612             
    613              if(ret == STATUS_SUCCESS) {
    614               //1.真正恢复HDI hash table-更新了新的root table
    615               ret=Truly_FTL_HDI_hash_table_restore();  
    616              }
    617          
    618             //2.恢复MAPI―-更新了新的root table，更新了PMT部分的BDT
    619             if(ret == STATUS_SUCCESS) {
    620               FTL_MAPI_restore();
    621             }
    622             
    623             /*
    624             //2.真正恢复MAPI―没有操作
    625             if(ret == STATUS_SUCCESS) {
    626               ret=Truly_FTL_MAPI_restore();
    627             }*/
    628           
    629           
    630            
    631              //3.恢复BDT table
    632             if(ret == STATUS_SUCCESS) {
    633               FTL_BDT_table_restore();
    634             }
    635              //3.真正恢复BDT table--更新了新的root table
    636             if(ret == STATUS_SUCCESS) {
    637              ret=Truly_FTL_BDT_table_restore();
    638             } 
    639             
    640          
    641             //4.恢复ROOT table 
    642              if(ret == STATUS_SUCCESS) {  
    643                ret=FTL_ROOT_table_restore();
    644             }
    645          
    646              /*
    647              //4.真正恢复ROOT table―没有操作 
    648              if(ret == STATUS_SUCCESS) {  
    649                ret=Truly_FTL_ROOT_table_restore();
    650             } */
    651          
    652           return ret;
    653          }
    654          
    655          
    656          
    657          STATUS Truly_UBI_table_restore(){
    658            
    659            STATUS ret; 
    660            
    661            
    662            //0.维护恢复前（LEB中的除data block区）的其他部分对应的PEB 
    663            UINT8 i;  
    664            PHY_BLOCK peb_before[DATA_START_BLOCK]; //56 
    665            PHY_BLOCK peb_after[DATA_START_BLOCK]; //56 
    666            for(i=0;i<DATA_START_BLOCK;i++){
    667              peb_before[i]=AREA_GetBlock(i);//LEB对应PEB
    668            }
    669            
    670            
    671            //1.恢复AREA table，即MAP II
    672             ret=Truly_UBI_MAPII_restore();
    673            
    674              
    675            //2.恢复INDEX table    
    676            if(ret == STATUS_SUCCESS){
    677             ret=Truly_UBI_INDEX_table_restore();    
    678            }
    679            
    680             //3.恢复ANCHOR table 
    681            if(ret == STATUS_SUCCESS){    
    682              ret=Truly_UBI_ANCHOR_table_restore(); 
    683            }
    684            
    685            //判断0-55的LEB所对应的PEB不变
    686            for(i=0;i<DATA_START_BLOCK;i++){
    687              peb_after[i]=AREA_GetBlock(i);//LEB对应PEB
    688              if(peb_after[i]==peb_before[i]){
    689                //uart_printf("%s: The PEB of LEB %d not change\r\n",__func__,i);
    690              }
    691            }
    692            
    693            
    694            return ret;  
    695          }
    696          
    697          
    698          STATUS Truly_FTL_table_restore(){
    699            STATUS ret= STATUS_SUCCESS;  
    700           
    701            return ret; 
    702          }
    703          
    704          //恢复MAP I
    705          #define PMT_CURRENT_BLOCK  (PM_NODE_BLOCK(root_table.pmt_current_block))
    706          #define PMT_CURRENT_PAGE   (PM_NODE_PAGE(root_table.pmt_current_block))
    707          #define PMT_RECLAIM_BLOCK  (PM_NODE_BLOCK(root_table.pmt_reclaim_block))
    708          #define PMT_RECLAIM_PAGE   (PM_NODE_PAGE(root_table.pmt_reclaim_block))
    709          
    710          extern STATUS pmt_reclaim_blocks();
    711          
    712          STATUS FTL_MAPI_restore(){  
    713            STATUS ret = STATUS_SUCCESS;
    714            UINT32 iClusterNum;//总簇数
    715            
    716            PM_NODE_ADDR iPM_NODE[PM_PER_NODE];//512
    717            PM_NODE_ADDR* cache_addr = NULL; 
    718            
    719            LOG_BLOCK block_stored;
    720            PAGE_OFF page_stored;  
    721            SPARE spare; 
    722            
    723            PMT_CLUSTER meta_data[PAGE_PER_PHY_BLOCK];//保存1个PMT块中写入的簇号
    724            
    725            UINT32 i,j; 
    726            
    727            PMT_CLUSTER pm_cluster;  
    728            
    729            //将PMT区中各LEB的BDT全部设为63,全脏，以便回收PMT中的块
    730            for (i = PMT_START_BLOCK; i < PMT_START_BLOCK + PMT_BLOCK_COUNT; i++) {
    731              block_dirty_table[i] = MAX_DIRTY_PAGES;//63 
    732            }  
    733            pmt_reclaim_blocks();//对PMT块区中的无效的映射进行回收，更新pmt的current块，保证从新的PMT块恢复MAPI
    734            
    735            
    736            //MAPI占8块，存到逻辑II的8个LEB块中   
    737            iClusterNum=((g_LBAnum + PM_PER_NODE - 1) / PM_PER_NODE);//总簇数471   
    738            cache_addr = &(iPM_NODE[0]);
    739            PMT_Init();//将内存中的映射清空
    740            
    741            for(i=0;i<iClusterNum;i=i+PAGE_PER_PHY_BLOCK-1){      
    742                
    743              for(j=0;j<PAGE_PER_PHY_BLOCK-1;j++){//j<63        
    744                pm_cluster=i+j; 
    745                //已保存的MAPI的位置
    746                block_stored=(pm_cluster/PAGE_PER_PHY_BLOCK)+PMTRESORE_START_BLOCK;//从LEB46块开始
    747                page_stored=pm_cluster % PAGE_PER_PHY_BLOCK;
    748                
    749                ret = UBI_Read(block_stored, page_stored, cache_addr, spare);
    750                
    751                if (ret == STATUS_SUCCESS) {     
    752                 
    753                  ret = UBI_Write(PMT_CURRENT_BLOCK, PMT_CURRENT_PAGE,cache_addr, spare, FALSE);
    754                  if (ret == STATUS_SUCCESS) {
    755                    meta_data[PMT_CURRENT_PAGE] = pm_cluster;
    756                   
    757                  }                 
    758                  PM_NODE_SET_BLOCKPAGE(root_table.page_mapping_nodes[pm_cluster],PMT_CURRENT_BLOCK, PMT_CURRENT_PAGE);
    759                  PM_NODE_SET_BLOCKPAGE(root_table.pmt_current_block, PMT_CURRENT_BLOCK, PMT_CURRENT_PAGE+1);
    760                }        
    761              }
    762              //每写63页MAP I后，在PMT的最后一块中写入该块中已写入对应的簇号
    763              if (ret == STATUS_SUCCESS) {
    764                ret = UBI_Write(PMT_CURRENT_BLOCK, PMT_CURRENT_PAGE, meta_data, NULL, FALSE);
    765                if (ret == STATUS_SUCCESS) {              
    766                  ret = pmt_reclaim_blocks();//更新pmt的current块，从新的PMT块继续恢复MAPI
    767                }       
    768              }     
    769            }
    770            
    771            //设置root_table.pmt_reclaim_block
    772            if (ret == STATUS_SUCCESS) {
    773               ret = UBI_Erase(PMT_CURRENT_BLOCK+1, PMT_CURRENT_BLOCK+1);
    774             }
    775            if (ret == STATUS_SUCCESS) {
    776               PM_NODE_SET_BLOCKPAGE(root_table.pmt_reclaim_block, PMT_CURRENT_BLOCK+1, 0);
    777               block_dirty_table[PMT_CURRENT_BLOCK+1] = 0;
    778            }
    779            
    780            //todo：是否需要在最后1个PMT块（未用完）的最后1页写入已写入的簇号？  
    781            
    782            return ret; 
    783          }
    784          
    785          
    786          STATUS Truly_FTL_MAPI_restore(){
    787           STATUS ret = STATUS_SUCCESS;
    788           return ret; 
    789          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FTL_BgTasks
       8   FTL_Capacity
         8 __aeabi_uidiv
       0   FTL_CheckWP
       8   FTL_Flush
         8   -> UBI_Flush
       8   FTL_Format
         8   -> BDT_Format
         8   -> DATA_Format
         8   -> HDI_Format
         8   -> PMT_Format
         8   -> ROOT_Format
         8   -> UBI_Format
         8   -> UBI_Init
      16   FTL_Init
        16   -> BDT_Init
        16   -> DATA_Commit
        16   -> DATA_IsFull
        16   -> DATA_Reclaim
        16   -> DATA_Replay
        16   -> HDI_Init
        16   -> PMT_Init
        16   -> ROOT_Init
        16   -> UBI_Init
    2344   FTL_MAPI_restore
      2344   -> PMT_Init
      2344   -> UBI_Erase
      2344   -> UBI_Read
      2344   -> UBI_Write
      2344   -> pmt_reclaim_blocks
      2344 __aeabi_uidivmod
    2088   FTL_MAPI_store
      2088   -> UBI_Read
      2088   -> UBI_Write
      2088 __aeabi_uidivmod
      16   FTL_Read
        16   -> PMT_Search
        16   -> UBI_Read
       0   FTL_SetWP
      16   FTL_Trim
        16   -> FTL_Write
       8   FTL_UBI_RestoreImage
         8   -> FTL_table_restore
      16   FTL_UBI_StartLockImage
        16   -> DATA_Commit
        16   -> DATA_Reclaim
        16   -> DATA_Replay
        16   -> FTL_table_store
        16   -> UBI_Erase
      24   FTL_Write
        24   -> DATA_Commit
        24   -> DATA_IsFull
        24   -> DATA_Reclaim
        24   -> DATA_Write
        24   -> FTL_UBI_RestoreImage
        24   -> FTL_UBI_StartLockImage
        24   -> HDI_IsHotPage
        24   -> uart_printf
       8   FTL_table_restore
         8   -> FTL_BDT_table_restore
         8   -> FTL_HDI_hash_table_restore
         8   -> FTL_MAPI_restore
         8   -> FTL_ROOT_table_restore
         8   -> Truly_FTL_BDT_table_restore
         8   -> Truly_FTL_HDI_hash_table_restore
       8   FTL_table_store
         8   -> FTL_BDT_table_store
         8   -> FTL_HDI_hash_table_store
         8   -> FTL_MAPI_store
         8   -> FTL_ROOT_table_store
       0   Truly_FTL_MAPI_restore
       0   Truly_FTL_table_restore
     464   Truly_UBI_table_restore
       464   -> AREA_GetBlock
       464   -> Truly_UBI_ANCHOR_table_restore
       464   -> Truly_UBI_INDEX_table_restore
       464   -> Truly_UBI_MAPII_restore
       8   UBI_table_restore
         8   -> UBI_ANCHOR_table_restore
         8   -> UBI_INDEX_table_restore
         8   -> UBI_MAPII_restore
       8   UBI_table_store
         8   -> UBI_ANCHOR_table_store
         8   -> UBI_INDEX_table_store
         8   -> UBI_MAPII_store
      40   printint
        40   -> UartWrite
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      56   printuint
        56   -> UartWrite
        56 __aeabi_uidiv
        56 __aeabi_uidivmod
      40   uart_printf
        40   -> UartWrite
        40   -> printint
        40   -> printuint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       8  ?_0
      84  ?_1
      16  ?_2
      60  ?_3
      16  ?_4
      36  ?_5
      36  ?_6
       4  FTL_BgTasks
      54  FTL_Capacity
       4  FTL_CheckWP
      22  FTL_Flush
      84  FTL_Format
     266  FTL_Init
     362  FTL_MAPI_restore
     126  FTL_MAPI_store
      38  FTL_Read
       4  FTL_SetWP
      38  FTL_Trim
      14  FTL_UBI_RestoreImage
     108  FTL_UBI_StartLockImage
     236  FTL_Write
      82  FTL_table_restore
      52  FTL_table_store
       8  Truly_FTL_MAPI_restore
       8  Truly_FTL_table_restore
     120  Truly_UBI_table_restore
      36  UBI_table_restore
      36  UBI_table_store
      20  digits
      20  digits
       4  g_LBAnum
     104  printint
      64  printuint
       4  tag
     210  uart_printf
      12  -- Other

 
     8 bytes in section .bss
    40 bytes in section .data
   268 bytes in section .rodata
 2 192 bytes in section .text
 
 2 192 bytes of CODE  memory
   268 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: 9
