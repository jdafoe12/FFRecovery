###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.5.9725/W32 for ARM        02/Aug/2023  19:53:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\sys\lpc313x\lib\lpc313x_cgu_driver.c
#    Command line =  
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\sys\lpc313x\lib\lpc313x_cgu_driver.c
#        -D BOOT_LEVEL_2 -lcN
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\Debug\List
#        -o C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\..\..\ -I
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\..\..\sys\lpc313x\bsp\
#        -I
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\..\..\sys\lpc313x\csp\
#        -I
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\..\..\sys\lpc313x\lib\
#        -I
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\..\..\sys\lpc313x\usb\
#        --cpu_mode thumb -Ol --use_c++_inline
#    List file    =  
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\Debug\List\lpc313x_cgu_driver.lst
#    Object file  =  
#        C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\prj\iar\Debug\Obj\lpc313x_cgu_driver.o
#
###############################################################################

C:\Users\bchen-adm\Desktop\FFRecovery2\nsac-hiftl\sys\lpc313x\lib\lpc313x_cgu_driver.c
      1          /***********************************************************************
      2           * $Id:: lpc313x_cgu_driver.c 3674 2010-06-05 01:53:13Z usb10131       $
      3           *
      4           * Project: LPC313x CGU driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the lpc313x CGU.
      8           *
      9           ***********************************************************************
     10           * Software that is described herein is for illustrative purposes only
     11           * which provides customers with programming information regarding the
     12           * products. This software is supplied "AS IS" without any warranties.
     13           * NXP Semiconductors assumes no responsibility or liability for the
     14           * use of the software, conveys no license or title under any patent,
     15           * copyright, or mask work right to the product. NXP Semiconductors
     16           * reserves the right to make changes in the software without
     17           * notification. NXP Semiconductors also make no representation or
     18           * warranty that such application will be suitable for the specified
     19           * use without further testing or modification.
     20           *********************************************************************/
     21          
     22          #include "lpc313x_cgu_driver.h"
     23          
     24          /***********************************************************************
     25          * CGU driver package data
     26          ***********************************************************************/
     27          struct _CGU_DRIVER_DAT
     28          {
     29             UNS_32 clkin_freq[CGU_FIN_SELECT_MAX];
     30             BOOL_32 init;
     31          } g_cgu_driver;
     32          
     33          /***********************************************************************
     34          * CGU driver private functions
     35          **********************************************************************/
     36          /***********************************************************************
     37          *
     38          * Function: cgu_fdiv_num_bits
     39          *
     40          * Purpose: calculate int(log2(i))+1
     41          *
     42          * Processing:
     43          *     This algorithm is used to calculate the above said formula.
     44          *     This is used to calculate the madd and msub width in frac div
     45          *     registers.Reasonably fast.
     46          *
     47          * Parameters:
     48          *     i : Number
     49          *
     50          * Outputs: None
     51          *
     52          * Returns: int(log2(i))+1
     53          *
     54          * Notes: None
     55          *
     56          **********************************************************************/
     57          static UNS_32 cgu_fdiv_num_bits(unsigned int i)
     58          {
     59             UNS_32 x = 0, y = 16;
     60          
     61             for (; y > 0; y = y >> 1)
     62             {
     63                if (i >> y)
     64                {
     65                   x += y;
     66                   i = i >> y;
     67                }
     68             }
     69          
     70             if (i)
     71                x++;
     72          
     73             return x;
     74          }
     75          
     76          /***********************************************************************
     77          *
     78          * Function: cgu_clkid2esrid
     79          *
     80          * Purpose: Finds ESR Id corresponding to the requested clock Id
     81          *
     82          * Processing:
     83          *     Finds ESR index corresponding to the requested clock Id.
     84          *
     85          * Parameters:
     86          *     clkid : clock Id.
     87          *
     88          * Outputs: None
     89          *
     90          * Returns: ESR Id corresponding to clock Id
     91          *
     92          * Notes: None
     93          *
     94          **********************************************************************/
     95          UNS_32 cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
     96          {
     97             UNS_32 esrIndex = (UNS_32)clkid;
     98          
     99             switch (clkid)
    100             {
    101                case CGU_SB_I2SRX_BCK0_ID:
    102                case CGU_SB_I2SRX_BCK1_ID:
    103                case CGU_SB_SYSCLK_O_ID:
    104                   /* invalid esr index. No ESR register for these clocks */
    105                   esrIndex = CGU_INVALID_ID;
    106                   break;
    107          
    108                case CGU_SB_SPI_CLK_ID:
    109                case CGU_SB_SPI_CLK_GATED_ID:
    110                   esrIndex = esrIndex - 2;
    111                   break;
    112                default:
    113                   /* do nothing */
    114                   break;
    115             }
    116          
    117             return esrIndex;
    118          }
    119          /***********************************************************************
    120          *
    121          * Function: cgu_DomainId2bcrid
    122          *
    123          * Purpose: Finds BCR Id corresponding to the requested domain Id
    124          *
    125          * Processing:
    126          *     Finds BCR index corresponding to the requested domain Id.
    127          *
    128          * Parameters:
    129          *     domainid : Domain ID
    130          *
    131          * Outputs: None
    132          *
    133          * Returns: BCR Id corresponding to domain Id
    134          *
    135          * Notes: None
    136          *
    137          **********************************************************************/
    138          UNS_32 cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
    139          {
    140             UNS_32 bcridx = CGU_INVALID_ID;
    141             switch (domainid)
    142             {
    143                case CGU_SB_SYS_BASE_ID:
    144                case CGU_SB_AHB0_APB0_BASE_ID:
    145                case CGU_SB_AHB0_APB1_BASE_ID:
    146                case CGU_SB_AHB0_APB2_BASE_ID:
    147                   bcridx = domainid;
    148                   break;
    149                case CGU_SB_CLK1024FS_BASE_ID:
    150                   bcridx = CGU_SB_NR_BCR - 1;
    151                   break;
    152                default:
    153                   bcridx = CGU_INVALID_ID;
    154                   break;
    155             }
    156             return bcridx;
    157          }
    158          /***********************************************************************
    159          *
    160          * Function: cgu_ClkId2DomainId
    161          *
    162          * Purpose: Finds domain & sub-domain Ids for requested clock
    163          *
    164          * Processing:
    165          *     Finds domain index and fractional divider index for the requested
    166          *	   clock.
    167          *
    168          * Parameters:
    169          *     clkid : clock Id.
    170          *     pDomainId : pointer to domain index.
    171          *     pSubdomainId : pointer to fractional divider index.
    172          *
    173          * Outputs:
    174          *     pDomainId : pointer to domain index.
    175          *     pSubdomainId : pointer to fractional divider index.
    176          *
    177          * Returns: None
    178          *
    179          * Notes: None
    180          *
    181          **********************************************************************/
    182          void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
    183                                  UNS_32* pSubdomainId)
    184          {
    185             UNS_32 esrIndex, esrReg;
    186             UNS_32 fracdiv_base = CGU_INVALID_ID;
    187          
    188             /*    1. Get the domain ID */
    189          
    190             if (clkid <= CGU_SYS_LAST)
    191             {
    192                *pDomainId = CGU_SB_SYS_BASE_ID;
    193                fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
    194          
    195             }
    196             else 	if (clkid <= CGU_AHB0APB0_LAST)
    197             {
    198                *pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
    199                fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
    200          
    201             }
    202             else 	if (clkid <= CGU_AHB0APB1_LAST)
    203             {
    204                *pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
    205                fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
    206          
    207             }
    208             else 	if (clkid <= CGU_AHB0APB2_LAST)
    209             {
    210                *pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
    211                fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
    212          
    213             }
    214             else 	if (clkid <= CGU_AHB0APB3_LAST)
    215             {
    216                *pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
    217                fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
    218          
    219             }
    220             else 	if (clkid == CGU_PCM_LAST)
    221             {
    222                *pDomainId = CGU_SB_PCM_BASE_ID;
    223                fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
    224          
    225             }
    226             else 	if (clkid == CGU_UART_LAST)
    227             {
    228                *pDomainId = CGU_SB_UART_BASE_ID;
    229                fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
    230          
    231             }
    232             else 	if (clkid <= CGU_CLK1024FS_LAST)
    233             {
    234                *pDomainId = CGU_SB_CLK1024FS_BASE_ID;
    235                fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
    236          
    237             }
    238             else 	if (clkid == CGU_I2SRX_BCK0_LAST)
    239             {
    240                *pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
    241                fracdiv_base = CGU_INVALID_ID;
    242          
    243             }
    244             else 	if (clkid == CGU_I2SRX_BCK1_LAST)
    245             {
    246                *pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
    247                fracdiv_base = CGU_INVALID_ID;
    248          
    249             }
    250             else 	if (clkid <= CGU_SPI_LAST)
    251             {
    252                *pDomainId = CGU_SB_SPI_CLK_BASE_ID;
    253                fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
    254          
    255             }
    256             else
    257             {
    258                *pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
    259                fracdiv_base = CGU_INVALID_ID;
    260             }
    261          
    262             *pSubdomainId = CGU_INVALID_ID;
    263          
    264             /* read the clocks ESR to get the fractional divider */
    265             esrIndex = cgu_clkid2esrid(clkid);
    266          
    267             if (CGU_INVALID_ID != esrIndex)
    268             {
    269                /* read the clocks ESR to get the fractional divider */
    270                esrReg = CGU_SB->clk_esr[esrIndex];
    271          
    272                /* A clock may not be connected to any sub-domain and it might be
    273                connected directly to domain. This is also a valid combination. So,
    274                errror should not be returned */
    275                if (esrReg & CGU_SB_ESR_ENABLE)
    276                {
    277                   *pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
    278                }
    279             }
    280          
    281          }
    282          
    283          /***********************************************************************
    284          *
    285          * Function: cgu_fdiv_config
    286          *
    287          * Purpose:
    288          *
    289          * Processing:
    290          *     .
    291          *
    292          * Parameters:
    293          *     i : Number
    294          *
    295          * Outputs: None
    296          *
    297          * Returns:
    298          *
    299          * Notes: None
    300          *
    301          **********************************************************************/
    302          /* frac divider config function */
    303          UNS_32 cgu_fdiv_config(UNS_32 fdId,
    304                                 CGU_FDIV_SETUP_T fdivCfg,
    305                                 BOOL_32 enable,
    306                                 BOOL_32 dyn_fdc)
    307          {
    308             UNS_32 conf, maddw, msubw, maxw, fdWidth;
    309             INT_32 madd, msub;
    310          
    311             /* calculating program values to see if they fit in fractional divider*/
    312             madd = fdivCfg.m - fdivCfg.n;
    313             msub = -fdivCfg.n;
    314          
    315             /* Find required bit width of madd & msub:*/
    316             maddw = cgu_fdiv_num_bits((UNS_32)madd);
    317             msubw = cgu_fdiv_num_bits((UNS_32)fdivCfg.n);
    318             maxw = (maddw > msubw) ? maddw : msubw;
    319             fdWidth = CGU_SB_BASE0_FDIV0_W;
    320          
    321             if (fdId == CGU_SB_BASE7_FDIV_LOW_ID)
    322             {
    323                /* for Frac divider 17 the bit width is 13 */
    324                fdWidth = CGU_SB_BASE7_FDIV0_W;
    325             }
    326          
    327             /* Calculate Configure parameter:*/
    328             conf = ((((1 << fdWidth) - 1) &
    329                      (msub << (fdWidth - maxw))) <<
    330                     (fdWidth + CGU_SB_FDC_MADD_POS)) |
    331                    (madd << (fdWidth - maxw + CGU_SB_FDC_MADD_POS));
    332          
    333             /* check whther 50% duty cycle is needed for this divider*/
    334             if (fdivCfg.stretch)
    335                conf |= CGU_SB_FDC_STRETCH;
    336             /* check whehter to enable the divider immediately */
    337             if (enable)
    338                conf |= CGU_SB_FDC_RUN;
    339          
    340             /* finally configure the divider*/
    341             if (FALSE == dyn_fdc)
    342             {
    343                CGU_SB->base_fdc[fdId] = conf;
    344             }
    345             else
    346             {
    347                if (fdId < CGU_SB_NR_DYN_FDIV)
    348                   CGU_SB->base_dyn_fdc[fdId] = conf | CGU_SB_DYN_FDC_ALLOW;
    349             }
    350          
    351             return conf;
    352          }
    353          /***********************************************************************
    354          *
    355          * Function: cgu_init_domain_clks
    356          *
    357          * Purpose:
    358          *
    359          * Processing:
    360          *     .
    361          *
    362          * Parameters:
    363          *     i : Number
    364          *
    365          * Outputs: None
    366          *
    367          * Returns:
    368          *
    369          * Notes: None
    370          *
    371          **********************************************************************/
    372          void cgu_init_domain_clks(CGU_DOMAIN_CFG_T* pDomain)
    373          {
    374             UNS_32 fd_id, clk_id, esr_id;
    375             CGU_SUB_DOMAIN_CFG_T* psub = pDomain->sub;
    376             UNS_32 bcr_id = cgu_DomainId2bcrid(pDomain->id);
    377             UNS_32 fdiv_conf = 0;
    378          
    379             if (bcr_id != CGU_INVALID_ID)
    380             {
    381                /* disable BCR for domain */
    382                CGU_SB->base_bcr[bcr_id] = 0;
    383             }
    384          
    385             /* configure frac divider */
    386             for (fd_id = 0; fd_id < pDomain->fdiv_cnt; fd_id++, psub++)
    387             {
    388                /* set fractional dividers but don't enable them yet*/
    389                fdiv_conf = cgu_fdiv_config(fd_id + pDomain->fdiv_min, psub->fdiv_cfg, FALSE, FALSE);
    390          
    391                /* enable frac divider only if it has valid settings. Or else it may be unused*/
    392                if (fdiv_conf != 0)
    393                {
    394                   /* select frac div for each clock in this sub domain*/
    395                   for (clk_id = 0; clk_id <= pDomain->clk_cnt; clk_id++)
    396                   {
    397                      esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)(clk_id + pDomain->clk_min));
    398                      if (esr_id != CGU_INVALID_ID)
    399                      {
    400                         /* check whether clock belongs to this sub-domain */
    401                         if (psub->clks & _BIT(clk_id))
    402                         {
    403                            /* finally configure the clock*/
    404                            CGU_SB->clk_esr[esr_id] = CGU_SB_ESR_SELECT(fd_id) | CGU_SB_ESR_ENABLE;
    405                         }
    406                      }
    407                   }
    408                   /* enable frac divider */
    409                   CGU_SB->base_fdc[fd_id + pDomain->fdiv_min] |= CGU_SB_FDC_RUN;
    410                }
    411             }
    412             if (bcr_id != CGU_INVALID_ID)
    413             {
    414                /* enable BCR for domain */
    415                CGU_SB->base_bcr[bcr_id] = CGU_SB_BCR_FD_RUN;
    416             }
    417             /* select input for domain*/
    418             cgu_set_base_freq(pDomain->id, pDomain->fin_sel);
    419          }
    420          
    421          
    422          /***********************************************************************
    423          * CGU driver public functions
    424          ***********************************************************************/
    425          /***********************************************************************
    426          *
    427          * Function: cgu_init
    428          *
    429          * Purpose:
    430          *
    431          * Processing:
    432          *     .
    433          *
    434          * Parameters:
    435          *     i : Number
    436          *
    437          * Outputs: None
    438          *
    439          * Returns:
    440          *
    441          * Notes: None
    442          *
    443          **********************************************************************/
    444          void cgu_init(UNS_32 clkin_freq[CGU_FIN_SELECT_MAX])
    445          {
    446             UNS_32 i = CGU_FIN_SELECT_MAX;
    447          
    448             /* initialize the CGU Driver data */
    449             while (i--)
    450             {
    451                g_cgu_driver.clkin_freq[i] = clkin_freq[i];
    452             }
    453          
    454             /* set init  done */
    455             g_cgu_driver.init = TRUE;
    456          
    457          }
    458          /***********************************************************************
    459          *
    460          * Function: cgu_reset_all_clks
    461          *
    462          * Purpose:
    463          *
    464          * Processing:
    465          *     .
    466          *
    467          * Parameters:
    468          *     i : Number
    469          *
    470          * Outputs: None
    471          *
    472          * Returns:
    473          *
    474          * Notes: None
    475          *
    476          **********************************************************************/
    477          void cgu_reset_all_clks(void)
    478          {
    479             CGU_DOMAIN_ID_T domainId;
    480             UNS_32 bcrId, esr_id;
    481             UNS_32 enable, i;
    482          
    483             /* switch all clocks to FFAST */
    484             for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
    485             {
    486                /* switch reference clock in to FFAST */
    487                cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
    488                /* check if the domain has a BCR*/
    489                bcrId = cgu_DomainId2bcrid(domainId);
    490                /* disable all BCRs */
    491                if (bcrId != CGU_INVALID_ID)
    492                {
    493                   CGU_SB->base_bcr[bcrId] = 0;
    494                }
    495             }
    496             /* disable all clocks except the needed ones */
    497             for (i = 0; i < (CGU_SYSCLK_O_LAST + 1); i++)
    498             {
    499                /* Clear the clocks ESR to deselect fractional divider */
    500                esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)i);
    501          
    502                if (CGU_INVALID_ID != esr_id)
    503                {
    504                   CGU_SB->clk_esr[esr_id] = 0;
    505                }
    506          
    507                if (i < 31)
    508                {
    509                   enable = CGU_DEF_CLKS_0_31 & _BIT(i);
    510                }
    511                else
    512                {
    513                   if (i < 63)
    514                   {
    515                      enable = CGU_DEF_CLKS_32_63 & _BIT(i - 32);
    516                   }
    517                   else
    518                   {
    519                      enable = CGU_DEF_CLKS_64_92 & _BIT(i - 64);
    520                   }
    521                }
    522                /**********************************************************/
    523                /* initiliase external enables and ext_outs  */
    524                /**********************************************************/
    525                /* set external enable for all possible clocks to conserve
    526                power. cgu_clk_set_exten() function sets CGU_SB_PCR_EXTEN_EN
    527                for allowed clocks only. */
    528                cgu_clk_set_exten((CGU_CLOCK_ID_T)i, TRUE);
    529          
    530                /* set enable-out’s for only the following clocks */
    531                if ((i == CGU_SB_ARM926_BUSIF_CLK_ID) ||
    532                      (i == CGU_SB_MPMC_CFG_CLK_ID))
    533                {
    534                   CGU_SB->clk_pcr[i] |= CGU_SB_PCR_ENOUT_EN;
    535                }
    536                else
    537                {
    538                   CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_ENOUT_EN;
    539                }
    540          
    541                /* disable all clocks except the needed ones */
    542                if (enable)
    543                {
    544                   CGU_SB->clk_pcr[i] |= CGU_SB_PCR_RUN;
    545                }
    546                else
    547                {
    548                   CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_RUN;
    549                }
    550             }
    551             /* disable all fractional dividers */
    552             for (i = 0; i < CGU_SB_NR_FRACDIV; i++)
    553             {
    554                CGU_SB->base_fdc[i] &= ~CGU_SB_FDC_RUN;
    555             }
    556          }
    557          
    558          /***********************************************************************
    559          *
    560          * Function: cgu_init_clks
    561          *
    562          * Purpose:
    563          *
    564          * Processing:
    565          *     .
    566          *
    567          * Parameters:
    568          *     i : Number
    569          *
    570          * Outputs: None
    571          *
    572          * Returns:
    573          *
    574          * Notes: None
    575          *
    576          **********************************************************************/
    577          /* select frac div for each clk */
    578          LPC_STATUS cgu_init_clks(const CGU_CLKS_INIT_T* pClksCfg)
    579          {
    580             CGU_DOMAIN_CFG_T domain;
    581          
    582             /* check whether driver is initialized */
    583             if (g_cgu_driver.init == FALSE)
    584             {
    585                return _ERROR;
    586             }
    587             /* reset all clocks and connect them to FFAST */
    588             cgu_reset_all_clks();
    589          
    590             /**********************************************************/
    591             /* initiliase Domain0 = SYS_BASE clocks                   */
    592             /**********************************************************/
    593             domain.id = CGU_SB_SYS_BASE_ID;
    594             domain.fin_sel = pClksCfg->domain0.fin_sel;
    595             domain.clk_min = CGU_SYS_FIRST;
    596             domain.clk_cnt = (CGU_SYS_LAST - CGU_SYS_FIRST) + 1;
    597             domain.fdiv_min = CGU_SB_BASE0_FDIV_LOW_ID;
    598             domain.fdiv_cnt = CGU_SB_BASE0_FDIV_CNT;
    599             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain0.sub[0];
    600             /* initialize all clocks and frac dividers for this domain */
    601             cgu_init_domain_clks(&domain);
    602          
    603             /**********************************************************/
    604             /* initiliase Domain1 = AHB0APB0_BASE clocks */
    605             /**********************************************************/
    606             domain.id = CGU_SB_AHB0_APB0_BASE_ID;
    607             domain.fin_sel = pClksCfg->domain1.fin_sel;
    608             domain.clk_min = CGU_AHB0APB0_FIRST;
    609             domain.clk_cnt = (CGU_AHB0APB0_LAST - CGU_AHB0APB0_FIRST) + 1;
    610             domain.fdiv_min = CGU_SB_BASE1_FDIV_LOW_ID;
    611             domain.fdiv_cnt = CGU_SB_BASE1_FDIV_CNT;
    612             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain1.sub[0];
    613             /* initialize all clocks and frac dividers for this domain */
    614             cgu_init_domain_clks(&domain);
    615          
    616             /**********************************************************/
    617             /* initiliase Domain2 = AHB0APB1_BASE clocks */
    618             /**********************************************************/
    619             domain.id = CGU_SB_AHB0_APB1_BASE_ID;
    620             domain.fin_sel = pClksCfg->domain2.fin_sel;
    621             domain.clk_min = CGU_AHB0APB1_FIRST;
    622             domain.clk_cnt = (CGU_AHB0APB1_LAST - CGU_AHB0APB1_FIRST) + 1;
    623             domain.fdiv_min = CGU_SB_BASE2_FDIV_LOW_ID;
    624             domain.fdiv_cnt = CGU_SB_BASE2_FDIV_CNT;
    625             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain2.sub[0];
    626             /* initialize all clocks and frac dividers for this domain */
    627             cgu_init_domain_clks(&domain);
    628          
    629             /**********************************************************/
    630             /* initiliase Domain3 = AHB0APB2_BASE clocks */
    631             /**********************************************************/
    632             domain.id = CGU_SB_AHB0_APB2_BASE_ID;
    633             domain.fin_sel = pClksCfg->domain3.fin_sel;
    634             domain.clk_min = CGU_AHB0APB2_FIRST;
    635             domain.clk_cnt = (CGU_AHB0APB2_LAST - CGU_AHB0APB2_FIRST) + 1;
    636             domain.fdiv_min = CGU_SB_BASE3_FDIV_LOW_ID;
    637             domain.fdiv_cnt = CGU_SB_BASE3_FDIV_CNT;
    638             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain3.sub[0];
    639             /* initialize all clocks and frac dividers for this domain */
    640             cgu_init_domain_clks(&domain);
    641          
    642             /**********************************************************/
    643             /* initiliase Domain4 = AHB0APB3_BASE clocks */
    644             /**********************************************************/
    645             domain.id = CGU_SB_AHB0_APB3_BASE_ID;
    646             domain.fin_sel = pClksCfg->domain4.fin_sel;
    647             domain.clk_min = CGU_AHB0APB3_FIRST;
    648             domain.clk_cnt = (CGU_AHB0APB3_LAST - CGU_AHB0APB3_FIRST) + 1;
    649             domain.fdiv_min = CGU_SB_BASE4_FDIV_LOW_ID;
    650             domain.fdiv_cnt = CGU_SB_BASE4_FDIV_CNT;
    651             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain4.sub[0];
    652             /* initialize all clocks and frac dividers for this domain */
    653             cgu_init_domain_clks(&domain);
    654          
    655             /**********************************************************/
    656             /* initiliase Domain5 = PCM_BASE clocks */
    657             /**********************************************************/
    658             domain.id = CGU_SB_PCM_BASE_ID;
    659             domain.fin_sel = pClksCfg->domain5.fin_sel;
    660             domain.clk_min = CGU_PCM_FIRST;
    661             domain.clk_cnt = 1;
    662             domain.fdiv_min = CGU_SB_BASE5_FDIV_LOW_ID;
    663             domain.fdiv_cnt = CGU_SB_BASE5_FDIV_CNT;
    664             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain5.sub[0];
    665             /* initialize all clocks and frac dividers for this domain */
    666             cgu_init_domain_clks(&domain);
    667          
    668             /**********************************************************/
    669             /* initiliase Domain6 = UART_BASE clocks */
    670             /**********************************************************/
    671             domain.id = CGU_SB_UART_BASE_ID;
    672             domain.fin_sel = pClksCfg->domain6.fin_sel;
    673             domain.clk_min = CGU_UART_FIRST;
    674             domain.clk_cnt = 1;
    675             domain.fdiv_min = CGU_SB_BASE6_FDIV_LOW_ID;
    676             domain.fdiv_cnt = CGU_SB_BASE6_FDIV_CNT;
    677             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain6.sub[0];
    678             /* initialize all clocks and frac dividers for this domain */
    679             cgu_init_domain_clks(&domain);
    680          
    681             /**********************************************************/
    682             /* initiliase Domain7 = CLK1024FS_BASE clocks */
    683             /**********************************************************/
    684             domain.id = CGU_SB_CLK1024FS_BASE_ID;
    685             domain.fin_sel = pClksCfg->domain7.fin_sel;
    686             domain.clk_min = CGU_CLK1024FS_FIRST;
    687             domain.clk_cnt = (CGU_CLK1024FS_LAST - CGU_CLK1024FS_FIRST) + 1;
    688             domain.fdiv_min = CGU_SB_BASE7_FDIV_LOW_ID;
    689             domain.fdiv_cnt = CGU_SB_BASE7_FDIV_CNT;
    690             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain7.sub[0];
    691             /* initialize all clocks and frac dividers for this domain */
    692             cgu_init_domain_clks(&domain);
    693          
    694             /**********************************************************/
    695             /* initiliase Domain8 = I2SRX_BCK0_BASE clocks */
    696             /**********************************************************/
    697             /* select input for domain*/
    698             cgu_set_base_freq(CGU_SB_I2SRX_BCK0_BASE_ID, pClksCfg->domain8.fin_sel);
    699          
    700             /**********************************************************/
    701             /* initiliase Domain9 = I2SRX_BCK1_BASE clocks */
    702             /**********************************************************/
    703             /* select input for domain*/
    704             cgu_set_base_freq(CGU_SB_I2SRX_BCK1_BASE_ID, pClksCfg->domain9.fin_sel);
    705          
    706             /**********************************************************/
    707             /* initiliase Domain10 = SPI_BASE clocks */
    708             /**********************************************************/
    709             domain.id = CGU_SB_SPI_CLK_BASE_ID;
    710             domain.fin_sel = pClksCfg->domain10.fin_sel;
    711             domain.clk_min = CGU_SPI_FIRST;
    712             domain.clk_cnt = (CGU_SPI_LAST - CGU_SPI_FIRST) + 1;
    713             domain.fdiv_min = CGU_SB_BASE10_FDIV_LOW_ID;
    714             domain.fdiv_cnt = CGU_SB_BASE10_FDIV_CNT;
    715             domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain10.sub[0];
    716             /* initialize all clocks and frac dividers for this domain */
    717             cgu_init_domain_clks(&domain);
    718          
    719             /**********************************************************/
    720             /* initiliase Domain11 = SYSCLK_O_BASE clocks */
    721             /**********************************************************/
    722             /* select input for domain*/
    723             cgu_set_base_freq(CGU_SB_SYSCLK_O_BASE_ID, pClksCfg->domain11.fin_sel);
    724          
    725             /**********************************************************/
    726             /* initiliase Dynamic fractional dividers TBD */
    727             /**********************************************************/
    728          #if 0
    729             /* disable BCR for domain */
    730             CGU_SB->base_bcr[0] = 0;
    731             for (i = 0; i < CGU_SB_NR_DYN_FDIV; i++)
    732             {
    733                if (pClksCfg->dyn_fdiv_cfg[i].cfg.n != 0)
    734                {
    735                   CGU_SB->base_dyn_sel[i] = pClksCfg->dyn_fdiv_cfg[i].sel;
    736                   cgu_fdiv_config(i, pClksCfg->dyn_fdiv_cfg[i].cfg, TRUE, TRUE);
    737                }
    738                else
    739                {
    740                   CGU_SB->base_dyn_fdc[i] = 0;
    741                }
    742          
    743             }
    744          
    745             CGU_SB->base_bcr[0] = CGU_SB_BCR_FD_RUN;
    746          #endif
    747          
    748          
    749             return _NO_ERROR;
    750          }
    751          
    752          /***********************************************************************
    753          *
    754          * Function: cgu_get_base_freq
    755          *
    756          * Purpose:
    757          *
    758          * Processing:
    759          *     .
    760          *
    761          * Parameters:
    762          *     i : Number
    763          *
    764          * Outputs: None
    765          *
    766          * Returns:
    767          *
    768          * Notes: None
    769          *
    770          **********************************************************************/
    771          INT_32 cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
    772          {
    773             INT_32 freq;
    774          
    775             /* check whether driver is initialized */
    776             if (g_cgu_driver.init == FALSE)
    777             {
    778                return _ERROR;
    779             }
    780          
    781             /* get base frequency for the domain */
    782             freq = g_cgu_driver.clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
    783          
    784             return freq;
    785          }
    786          
    787          /***********************************************************************
    788          *
    789          * Function: cgu_set_base_freq
    790          *
    791          * Purpose:
    792          *
    793          * Processing:
    794          *     .
    795          *
    796          * Parameters:
    797          *     i : Number
    798          *
    799          * Outputs: None
    800          *
    801          * Returns:
    802          *
    803          * Notes: None
    804          *
    805          **********************************************************************/
    806          void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, UNS_32 fin_sel)
    807          {
    808             UNS_32 baseSCR;
    809          
    810             /* Switch configuration register*/
    811             baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
    812             /* If fs1 is currently enabled set refId to fs2 and enable fs2*/
    813             if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1)
    814             {
    815                /* check if the selcted frequency is same as requested. If not switch.*/
    816                if (CGU_SB->base_fs1[baseid] != fin_sel)
    817                {
    818                   CGU_SB->base_fs2[baseid] = fin_sel;
    819          
    820                   /* Don't touch stop bit in SCR register*/
    821                   CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
    822                }
    823             }
    824             else
    825             {
    826                /* check if the selcted frequency is same as requested. If not switch.*/
    827                if (CGU_SB->base_fs2[baseid] != fin_sel)
    828                {
    829                   CGU_SB->base_fs1[baseid] = fin_sel;
    830          
    831                   /* Don't touch stop bit in SCR register*/
    832                   CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
    833                }
    834             }
    835          }
    836          
    837          /***********************************************************************
    838          *
    839          * Function: cgu_get_clk_freq
    840          *
    841          * Purpose:
    842          *
    843          * Processing:
    844          *     .
    845          *
    846          * Parameters:
    847          *     i : Number
    848          *
    849          * Outputs: None
    850          *
    851          * Returns:
    852          *
    853          * Notes: None
    854          *
    855          **********************************************************************/
    856          UNS_32 cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
    857          {
    858             UNS_32 freq = 0;
    859             CGU_DOMAIN_ID_T domainId;
    860             UNS_32 subDomainId;
    861             INT_32 n, m;
    862             UNS_32 fdcVal;
    863          
    864             /* check whether driver is initialized */
    865             if (g_cgu_driver.init == FALSE)
    866             {
    867                return 0;
    868             }
    869          
    870             /* get domain and frac div info for the clock */
    871             cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
    872          
    873             /* get base frequency for the domain */
    874             freq = g_cgu_driver.clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId])];
    875          
    876             /* direct connection  has no fraction divider*/
    877             if (subDomainId == CGU_INVALID_ID)
    878             {
    879                return freq;
    880             }
    881             /* read frac div control register value */
    882             fdcVal = CGU_SB->base_fdc[subDomainId];
    883          
    884             if (fdcVal & CGU_SB_FDC_RUN) /* Is the fracdiv enabled ?*/
    885             {
    886                /* Yes, so reverse calculation of madd and msub */
    887                {
    888                   INT_32 msub, madd;
    889          
    890                   if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID)
    891                   {
    892                      msub = CGU_SB_FDC_MSUB_GET(fdcVal);
    893                      madd = CGU_SB_FDC_MADD_GET(fdcVal);
    894                   }
    895                   else
    896                   {
    897                      msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
    898                      madd = CGU_SB_FDC17_MADD_GET(fdcVal);
    899                   }
    900          
    901                   /* remove trailing zeros */
    902                   while (!(msub & 1)  && !(madd & 1))
    903                   {
    904                      madd = madd >> 1;
    905                      msub = msub >> 1;
    906                   }
    907                   /* compute m and n values */
    908                   n = - msub;
    909                   m = madd + n;
    910                }
    911                /* check m and n are non-zero values */
    912                if ((n == 0) || (m == 0))
    913                {
    914                   return 0;
    915                }
    916                /* calculate the frequency based on m and n values */
    917                freq = (freq * n) / m ;
    918             }
    919             /* else There is no fractional divider in the clocks path */
    920          
    921             return  freq;
    922          }
    923          
    924          /***********************************************************************
    925          *
    926          * Function: cgu_set_subdomain_freq
    927          *
    928          * Purpose:
    929          *
    930          * Processing:
    931          *     .
    932          *
    933          * Parameters:
    934          *     i : Number
    935          *
    936          * Outputs: None
    937          *
    938          * Returns:
    939          *
    940          * Notes: None
    941          *
    942          **********************************************************************/
    943          void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
    944          {
    945             CGU_DOMAIN_ID_T domainId;
    946             UNS_32 subDomainId, base_freq, bcrId;
    947          
    948             /* get domain and frac div info for the clock */
    949             cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
    950          
    951             /* direct connection  has no fraction divider*/
    952             if (subDomainId != CGU_INVALID_ID)
    953             {
    954                /* store base freq */
    955                base_freq = CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]);
    956                /* switch domain to FFAST */
    957                cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
    958                /* check if the domain has a BCR*/
    959                bcrId = cgu_DomainId2bcrid(domainId);
    960                /* disable all BCRs */
    961                if (bcrId != CGU_INVALID_ID)
    962                {
    963                   CGU_SB->base_bcr[bcrId] = 0;
    964                }
    965                /* change fractional divider */
    966                cgu_fdiv_config(subDomainId, fdiv_cfg, TRUE, FALSE);
    967                /* enable BCRs */
    968                if (bcrId != CGU_INVALID_ID)
    969                {
    970                   CGU_SB->base_bcr[bcrId] = CGU_SB_BCR_FD_RUN;
    971                }
    972                /* switch domain to original base frequency */
    973                cgu_set_base_freq(domainId, base_freq);
    974             }
    975          }
    976          
    977          /***********************************************************************
    978          *
    979          * Function: cgu_hpll_config
    980          *
    981          * Purpose:
    982          *
    983          * Processing:
    984          *     .
    985          *
    986          * Parameters:
    987          *     i : Number
    988          *
    989          * Outputs: None
    990          *
    991          * Returns:
    992          *
    993          * Notes: None
    994          *
    995          **********************************************************************/
    996          void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
    997          {
    998             CGU_HP_CFG_REGS* hppll;
    999             UNS_32 switched_domains = 0;
   1000             CGU_DOMAIN_ID_T domainId;
   1001          
   1002             /**********************************************************
   1003             * switch domains connected to HPLL to FFAST automatically
   1004             ***********************************************************/
   1005             for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
   1006             {
   1007                if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
   1008                      (CGU_FIN_SELECT_HPPLL0 + pllid))
   1009                {
   1010                   /* switch reference clock in to FFAST */
   1011                   cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
   1012                   /* store the domain id to switch back to HPLL */
   1013                   switched_domains |= _BIT(domainId);
   1014                }
   1015             }
   1016          
   1017             /* get PLL regs */
   1018             hppll = &CGU_CFG->hp[pllid];
   1019          
   1020             /* disable clock, disable skew enable, power down pll,
   1021             * (dis/en)able post divider, (dis/en)able pre-divider,
   1022             * disable free running mode, disable bandsel,
   1023             * enable up limmiter, disable bypass
   1024             */
   1025             hppll->mode = CGU_HPLL_MODE_PD;
   1026          
   1027             /* Select fin */
   1028             hppll->fin_select = pllsetup->fin_select;
   1029          
   1030             /* M divider */
   1031             hppll->mdec = pllsetup->mdec & CGU_HPLL_MDEC_MASK;
   1032          
   1033             /* N divider */
   1034             hppll->ndec = pllsetup->ndec & CGU_HPLL_NDEC_MSK;
   1035          
   1036             /* P divider */
   1037             hppll->pdec = pllsetup->pdec & CGU_HPLL_PDEC_MSK;
   1038          
   1039             /* Set bandwidth */
   1040             hppll->selr = pllsetup->selr;
   1041             hppll->seli = pllsetup->seli;
   1042             hppll->selp = pllsetup->selp;
   1043          
   1044             /* Power up pll */
   1045             hppll->mode = (pllsetup->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
   1046          
   1047             /* store the estimated freq in driver data for future clk calcs */
   1048             g_cgu_driver.clkin_freq[CGU_FIN_SELECT_HPPLL0 + pllid] = pllsetup->freq;
   1049          
   1050             /* wait for PLL to lock */
   1051             while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
   1052          
   1053             /**********************************************************
   1054             * switch domains back to HPLL
   1055             ***********************************************************/
   1056             for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
   1057             {
   1058                if (switched_domains & _BIT(domainId))
   1059                {
   1060                   /* switch reference clock in to HPLL */
   1061                   cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
   1062                }
   1063             }
   1064          
   1065          }
   1066          
   1067          /***********************************************************************
   1068          *
   1069          * Function: cgu_hpll_status
   1070          *
   1071          * Purpose:
   1072          *
   1073          * Processing:
   1074          *     .
   1075          *
   1076          * Parameters:
   1077          *     i : Number
   1078          *
   1079          * Outputs: None
   1080          *
   1081          * Returns:
   1082          *
   1083          * Notes: None
   1084          *
   1085          **********************************************************************/
   1086          UNS_32 cgu_hpll_status(CGU_HPLL_ID_T pllid)
   1087          {
   1088             /* get PLL regs */
   1089             return CGU_CFG->hp[pllid].status;
   1090          }
   1091          
   1092          /***********************************************************************
   1093          *
   1094          * Function: cgu_soft_reset_module
   1095          *
   1096          * Purpose:
   1097          *
   1098          * Processing:
   1099          *     .
   1100          *
   1101          * Parameters:
   1102          *     i : Number
   1103          *
   1104          * Outputs: None
   1105          *
   1106          * Returns:
   1107          *
   1108          * Notes: None
   1109          *
   1110          **********************************************************************/
   1111          void cgu_soft_reset_module(CGU_MOD_ID_T modId)
   1112          {
   1113             volatile UNS_32 i;
   1114             volatile UNS_32* pmod_rst_reg = &(CGU_CFG->apb0_resetn_soft);
   1115          
   1116             /* All the reset registers are continously mapped with an address difference of 4 */
   1117             pmod_rst_reg += modId;
   1118          
   1119             /* clear and set the register */
   1120             *pmod_rst_reg = 0;
   1121             /* introduce some delay */
   1122             for (i = 0; i < 1000; i++);
   1123          
   1124             *pmod_rst_reg = CGU_CONFIG_SOFT_RESET;
   1125          }
   1126          
   1127          /***********************************************************************
   1128          *
   1129          * Function: cgu_clk_set_exten
   1130          *
   1131          * Purpose:
   1132          *
   1133          * Processing:
   1134          *     .
   1135          *
   1136          * Parameters:
   1137          *     i : Number
   1138          *
   1139          * Outputs: None
   1140          *
   1141          * Returns:
   1142          *
   1143          * Notes: None
   1144          *
   1145          **********************************************************************/
   1146          void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, BOOL_32 enable)
   1147          {
   1148             switch (clkid)
   1149             {
   1150                case CGU_SB_OTP_PCLK_ID:
   1151                case CGU_SB_PCM_APB_PCLK_ID:
   1152                case CGU_SB_EVENT_ROUTER_PCLK_ID:
   1153                case CGU_SB_ADC_PCLK_ID:
   1154                case CGU_SB_IOCONF_PCLK_ID:
   1155                case CGU_SB_CGU_PCLK_ID:
   1156                case CGU_SB_SYSCREG_PCLK_ID:
   1157                case CGU_SB_DMA_CLK_GATED_ID:
   1158                case CGU_SB_SPI_PCLK_GATED_ID:
   1159                case CGU_SB_SPI_CLK_GATED_ID:
   1160                case CGU_SB_PCM_CLK_IP_ID:
   1161                case CGU_SB_PWM_PCLK_REGS_ID:
   1162                   if (enable)
   1163                   {
   1164                      CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
   1165                   }
   1166                   else
   1167                   {
   1168                      CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
   1169                   }
   1170                   break;
   1171                   /* force disable for the following clocks */
   1172                case CGU_SB_I2C0_PCLK_ID:
   1173                case CGU_SB_I2C1_PCLK_ID:
   1174                case CGU_SB_WDOG_PCLK_ID:
   1175                case CGU_SB_UART_APB_CLK_ID:
   1176                case CGU_SB_LCD_PCLK_ID:
   1177                   CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
   1178                   break;
   1179                default:
   1180                   break;
   1181             }
   1182          }
   1183          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   cgu_ClkId2DomainId
        16   -> cgu_clkid2esrid
       4   cgu_DomainId2bcrid
       4   cgu_clk_set_exten
       4   cgu_clkid2esrid
      32   cgu_fdiv_config
        32   -> cgu_fdiv_num_bits
       4   cgu_fdiv_num_bits
       4   cgu_get_base_freq
      16   cgu_get_clk_freq
        16   -> cgu_ClkId2DomainId
        16 __aeabi_uidiv
      24   cgu_hpll_config
        24   -> cgu_set_base_freq
       0   cgu_hpll_status
       8   cgu_init
      40   cgu_init_clks
        40   -> cgu_init_domain_clks
        40   -> cgu_reset_all_clks
        40   -> cgu_set_base_freq
      32   cgu_init_domain_clks
        32   -> cgu_DomainId2bcrid
        32   -> cgu_clkid2esrid
        32   -> cgu_fdiv_config
        32   -> cgu_set_base_freq
      16   cgu_reset_all_clks
        16   -> cgu_DomainId2bcrid
        16   -> cgu_clk_set_exten
        16   -> cgu_clkid2esrid
        16   -> cgu_set_base_freq
       8   cgu_set_base_freq
      24   cgu_set_subdomain_freq
        24   -> cgu_ClkId2DomainId
        24   -> cgu_DomainId2bcrid
        24   -> cgu_fdiv_config
        24   -> cgu_set_base_freq
       8   cgu_soft_reset_module


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
     230  cgu_ClkId2DomainId
      40  cgu_DomainId2bcrid
     156  cgu_clk_set_exten
      40  cgu_clkid2esrid
     158  cgu_fdiv_config
      36  cgu_fdiv_num_bits
      44  cgu_get_base_freq
     166  cgu_get_clk_freq
     204  cgu_hpll_config
      16  cgu_hpll_status
      36  cgu_init
     412  cgu_init_clks
     192  cgu_init_domain_clks
     264  cgu_reset_all_clks
     126  cgu_set_base_freq
     118  cgu_set_subdomain_freq
      46  cgu_soft_reset_module
      32  g_cgu_driver

 
    32 bytes in section .bss
 2 372 bytes in section .text
 
 2 372 bytes of CODE memory
    32 bytes of DATA memory

Errors: none
Warnings: none
